<?xml version="1.0" ?>
<Book>
    <title>
        Мова програмування Сі
    </title>
    <author_group>
        <author>
            Глибовець М.М.,
        </author>
        <author>
            Глибовець А.М.,
        </author>
        <author>
            Проценко В.С.
        </author>
    </author_group>

    <date>Київ 2009 рік</date>

    <main>
        <foreward>

            ПЕРЕДМОВА

            Даний посібник з мови програмування Сі є упорядкованим конспектом лекцій, що читалися для
            студентів-другокурсників департаменту комп’ютерних технологій Національного Університету &amp;amp;quot;Києво-Могилянська
            Академія&amp;amp;quot; та факультету кібернетики Національного Київського університету ім.Т.Шевченка. За
            основу викладення матеріалу покладена методологія розробників мови Сі Кернігана Б., Рітчі Д., Фюэра А.
            У підручнику робиться спроба огляду основних синтаксичних структур мови Сі з наголосом на їх застосування
            при вирішенні різних практичних задач. Крім класичного матеріалу (основні оператори, дані, використання
            функцій та ін.) приділяється значна увага таким темам, як різнопланове використання покажчиків,
            конструювання нових типів даних (структури, поля, суміші), робота з файлами. Приводиться великий набір задач
            і варіанти їх розв’язку, набір лабораторних робіт для закріплення матеріалу.
            Автори підручника будуть вдячні за всі зауваження, спрямовані на виявлення недоліків та описок в матеріалі
            підручника.
        </foreward>

        <content>

            <sub_item>
                <item_title>1. Вступ</item_title>
                <text></text>
                <sub_item>
                    <item_title>1.1 Характеристика мови Сі</item_title>
                    <text>
                        Мова програмування Сі відноситься до мов програмування високого рівня з деякими операціями, які
                        притаманні мовам низького рівня. Для неї є характерним економний запис програм і функцій,
                        розвинутий апарат керування обчисленнями і опису структур даних [1,4,6]. Наявність великого
                        набору різних операцій і вмонтованих функцій дозволяє отримувати програми які по ефективності
                        наближаються до асемблерних. Простота мови забезпечує використання нескладних компіляторів [6].
                        Ці властивості мови особливо важливі для системних програмістів при написанні операційних
                        систем. Про це свідчить вдалий приклад написання на мові Сі операційної системи UNIX, яка не
                        орієнтована на жодну обчислювальну платформу.
                        Обробка Сі-програми проводиться в дві фази: препроцесором і транслятором.
                    </text>
                </sub_item>
                <sub_item>
                    <item_title>1.2. Істворія Сі</item_title>
                    <text>
                        Мова програмування Сі була розроблена Деннісом і Рітчі в Bell Labs під час роботи над
                        операційною системою UNIX в 1972 році і набула широкого розповсюдження на початку 80-х років
                        [4].
                        Серед переваг мови Сі можна виділити:
                        • сучасність - заключається в тому, що її структура примушує програміста використовувати
                        прогресивні технології створення програм: програмування зверху до низу, структурне
                        програмування, по крокову розробку модулів;
                        • ефективність - компактність запису програми і швидкодія виконання;
                        • сумісність - компілятори з мови Сі реалізовані на більш як 40-ка типах обчислювальних
                        пристроїв, починаючи з мікрокомп’ютерів і закінчуючи суперкомп’ютерами.
                    </text>
                </sub_item>
                <sub_item>
                    <item_title>1.3. Організація програми</item_title>
                    <text>
                        Загальна структура програми приводиться на малюнку 1.1.
                        Програма може включати одну або декілька функцій, команд препроцесора і зовнішніх описів.
                        Функції описують послідовності дій обробки даних. Команди препроцесора вказують на перетворення,
                        яким потрібно піддати програму до компіляції. Зовнішні описи характеризують дані, які
                        обробляються декількома функціями програми. Серед функцій обов’язково повинна бути одна головна
                        з іменем main(), з якої починається виконання всієї програми. Весь текст програми може
                        знаходиться в декількох файлах, імена яких описуються в директивах препроцесора.
                        Наведемо приклад можливої структури побудови програми.
                        #include &amp;amp;lt;stdio.h&amp;amp;gt;
                        #include ”file1.c’’
                        #include ”file2.c’’
                        float res;
                        main() /*головна програма*/
                        { int a,b;
                        float mida(), midg();
                        printf(”введіть 2 цілих числа \n’’);
                        scanf((”%d,%d’’, &amp;amp;a,&amp;amp;b);
                        if (a*b&amp;amp;gt;0)
                        { midg(a,b);
                        printf(”\n середнє геометричне дорівнює %5.4f’’, res);
                        }
                        else
                        {
                        mida(a,b);
                        printf(”\n середнє арифметичне дорівнює %5.4f’’, res);
                        }
                        де в файлі file1.c міститься функція
                        float mida(x,y);
                        int x,y;
                        {extern float res;
                        res=(x+y)/2;
                        return(res)
                        }
                        а в файлі file2.c міститься функція
                        float midg(x,y);
                        int x,y;
                        {extern float res;
                        res=sqrt(x*y);
                        return(res)
                        }
                        Перші три стрічки є вказівками препроцесору. Команда include вказує, що препроцесору потрібно
                        додати до тексту програми зміст файлів stdio.h
                        (стандартні бібліотеки введення-виведення) і файлів з іменем file1.c та file2.c . Імена
                        стандартних файлів беруться в дужки &amp;amp;lt; &amp;amp;gt;, а імена інших файлів - в лапки
                        ’’. Стрічка float res описує зовнішню змінну. Назва main() визначає одну з цих функцій як
                        головну. З неї починається виконання програми. Фігурні дужки є операторними дужками мови Сі.
                        Оператори int і float є операторами описувачами. Перший описує змінні цілого типу a і b, а
                        другий - дійсне значення результатів функцій mida() та midg(), які відповідно визначають середнє
                        арифметичне та середнє геометричне значення двох цілих. Дужки типу /* і */ визначають відповідно
                        початок і кінець коментарю. Оператори printf, scanf належать до групи операторів вводу-виводу, а
                        оператори if...else, return() - до групи операторів керування. Специфікація f в операторах
                        printf та scanf визначає, що ввід-вивід в мові СІ носить форматний характер. Параметри цих
                        операторів можна розбити на дві групи. Перша визначає специфікації інформації вводу-виводу, а
                        друга - змінні вводу-виводу. Як перша, так і друга частина може мати спеціальні символи, або
                        групи символів, чи бути пустою. Так в першому операторі printf текст взятий в лапки ‘ ’ визначає
                        специфікацію вводу. В результаті буде надруковано: введіть 2 цілих числа і потім, голівка
                        пристрою друку буде переведена на нову стрічку. Останню дію викликає наявність в специфікації
                        символів \n. Спеціальні символи специфікації оператору scanf типу % визначають початок формату
                        опису вводу-виводу змінної. Так символ d говорить про те що відповідна змінна повинна бути
                        змінною цілого типу, а f%5,4 визначає змінну дійсного типу з полями 5 і 4 для цілої та дробової
                        частини. Друга частина оператору scanf типу &amp;amp;а, &amp;amp;b визначає, що введені значення
                        будуть присвоєні змінним а та b. Оператор if визначається традиційним чином. Оператори mida(a,
                        b) та midg(a,b) є операторами функціями, а оператор return визначає значення що виробляє
                        відповідна функція, в тілі якої він знаходиться. Оператор extern визначає, що об’єкт його опису
                        є зовнішнім, доступним для всіх функцій цієї програми.


                        СІ-програма

                        Заголовок (директиви препроцесора)


                        main( )

                        Оператори (функція з якої починається виконання
                        програми завжди носить назву
                        main( ).)

                        функція f1( )

                        оператори (Функції- базові модулі для
                        розбудови програми)

                        ...........


                        функція fn( )

                        оператори

                        опису
                        Існує 5 типів присвоєння Ключові слова
                        операторів функція  дані
                        керування оператори
                        пустий


                        Мал.1.1.Структура програми в мові Сі.

                        Припустимо, що ми набрали текст цієї програми в якомусь редакторові і записали її в файл
                        exam11.c. Як ми вже зазначали існує більше 40 компіляторів мови Сі. Розглянемо варіант
                        компіляції нашої програми в OC UNIX.
                        Компілятор з мови Сі в OC UNIX називається СС. Тому для компіляції нашої програми потрібно
                        ввести команду: cc exam11.c
                        Якщо програма не має синтаксичних помилок, тоді на екрані дисплею буде виводитися символ
                        запрошення &amp;amp;gt;, в іншому випадку на екрані будуть виводитися повідомлення про помилки.
                        Будемо вважати, що наша програма не містить синтаксичних помилок і ми отримали запрошення . Це
                        буде означати, що з’явився новий файл з іменем a.out . В цьому файлі міститься файл з програмою,
                        вже готовою до виконання і отриманою в результаті трансляції ( чи компіляції ) нашої початкової
                        програми. Для її виконання ми повинні ввести команду: a.out. На екрані дисплею з’явиться фраза:
                        введіть два цілих числа і маркер переведеться на початок нової стрічки. Після набору через
                        розподільник двох цілих чисел, натиснемо клавішу ENTER. В залежності від значень, які ми ввели,
                        отримаємо друк середнє геометричне дорівнює. і його значення, або середнє арифметичне дорівнює.
                        і його значення.
                    </text>
                </sub_item>
                <questions>
						<q_title>
                        Вправи і завдання до розділу 1:
						</q_title>
						<question>
                        <text>1.1. Напишіть програму, яка друкує ваше ім’я.
						</text>
						<answers>
							<answer>1</answer>
							<answer>2</answer>
							<right>3</right>
							<answer>4</answer>
						</answers>
						</question>
						<question>
                        <text>1.2. Напишіть програму., яка друкує ваше ім’я, прізвище або адресу, використовуючи три, або більше стрічок повідомлення.
						</text>
						<answers>
							<answer>1</answer>
							<answer>2</answer>
							<right>3</right>
							<answer>4</answer>
						</answers>
						</question>
						<question>
                        <text>1.3. Напишіть програму, яка вкаже ваш вік в роках і днях. Припустіть, що кількість днів в високосному і невисокосному році - однакова.
						</text>
						<answers>
							<answer>1</answer>
							<answer>2</answer>
							<right>3</right>
							<answer>4</answer>
						</answers>
						</question>
						<question>
                        <text>
                    1.4. Напишіть програму, яка визначає вартість кількості золота, рівній вашій вазі, в припущенні, що вартість однієї трійської унції золота (31 грам) становить 400 $.
						</text>
						<answers>
							<answer>1</answer>
							<answer>2</answer>
							<right>3</right>
							<answer>4</answer>
						</answers>
						</question>
						<question>
                        <text>1.5*. Дано дві змінні a та b, значеннями яких є цілі числа. Написати програму, яка змінює місцями значення цих символів. Тобто значення змінної a присвоїти змінній b, а значення b – змінній a.
                    Використовувати допоміжні змінні забороняється.
						</text>
						<answers>
							<answer>1</answer>
							<answer>2</answer>
							<right>3</right>
							<answer>4</answer>
						</answers>
						</question>
                                 
                </questions>
            </sub_item>


            <sub_item>
                <item_title>
                    2. Дані в мові Сі
                </item_title>
                <text>
                    При використанні ЕОМ для розв’язку прикладних задач потрібно мати інструмент для опису інформації, з
                    якою працює комп’ютер на всьому протязі її обробки, починаючи з введення початкових даних і
                    закінчуючи виведенням результату обробки [2,3,6]. Іншими словами, програмі постійно потрібно
                    працювати з даними - числовими і символьними об’єктами, які несуть в собі інформацію, потрібну для
                    подальшого використання. Деякі дані ініціюються значеннями на початку, ще перед виконанням програми,
                    і залишаються незмінними до кінця виконання програми. Такі дані називають константами. Інші дані,
                    які можуть змінювати своє значення в програмі, називають змінними.
                </text>
                <sub_item>
                    <item_title>
                        2.1.Типи даних
                    </item_title>
                    <text>
                        Дані програми можуть бути різного типу. В залежності від типу до даних можна застосовувати різні
                        дії. Взагалі, тип даних визначається певною множиною значень об’єктів та сукупністю дій, які
                        можна виконати над цими об’єктами. Об’єкти, в свою чергу, можна поділити на дві великі групи:
                        скалярні та структурні. Скалярні об’єкти є неподільними, а структурні - є скінченою сукупністю
                        скалярних.
                        Якщо величина є константою, тоді компілятор розпізнає її тип по формі запису в програмі. Якщо ж
                        він має справу з змінною, тоді змінна повинна бути описана в одному з операторів опису.
                        В стандарті мови Сі існує сім ключових слів для визначення типу змінної (форми задання в пам’яті
                        ЕОМ): int, long, short, unsignеd, char, float, double. Перші чотири слова використовуються
                        окремо або в деякій комбінації типу unsigned short для опису цілих. Char описує символи, а два
                        останні описувачі - дійсні числа з плаваючою крапкою.
                        Нагадаємо, що найменша одиниця пам’яті називається бітом. Вона може приймати одне з значень: 0
                        або 1. Очевидно, що в один біт можна помістити дуже мало інформації. Тому біт є найпростішим
                        будівельним матеріалом для більш складніших компонент роботи з пам’яттю комп’ютера; таких як
                        байт і машинне слово. В більшості машин байт складається з 8 бітів, тому може приймати 256 (2 в
                        8 степені) комбінацій із 0 та 1. За допомогою цих комбінацій можуть кодуватись різні дані. В
                        восьми розрядних комп’ютерах слово займає 1 байт, в шістнадцяти розрядних - 2 байти і т.п.. Так,
                        сучасні комп’ютери можуть мати 32-х, 64-х розрядні та навіть більші машинні слова. Зрозуміло, що
                        чим більше слово, тим більше інформації можна в нього записати і працювати з нею як з
                        неподільною компонентою. Традиційно, комп’ютери мають спеціальні механізми для об’єднання
                        машинних слів в окремі спеціалізовані структури. Але робота з ними вимагає окремого розгляду і
                        приводить до ускладнення і відповідно уповільнення обробки програми комп’ютером.
                        Мова Сі дає користувачу можливість вибору розміру пам’яті для роботи з цілими числами. Так типу
                        int відповідає стандартна довжина слова, прийнята в машині яка використовується.
                    </text>
                </sub_item>
                <sub_item>
                    <item_title>
                        2.2.Опис даних цілого типу
                    </item_title>
                    <text>
                        Діапазон двохбайтових цілих чисел становить: від -32768 до 32767; чотирьохбайтових: від -231 до
                        2 31-1; відповідно діапазон беззнакових цілих від 0 до 65535 та від 0 до 2 31-1.
                        Згідно правилам Сі, число без десяткової крапки і без показника степені розглядається як ціле.
                        Тому 35 і -234 будуть цілими константами. Якщо ж ви бажаєте ввести цілу константу типу long ,
                        тоді мусите додати в кінці запису константи літеру L або l . Наприклад, 35l . В мові Сі є ще
                        інші особливості запису цілих констант, які пов’язані з вибором основи системи числення. Якщо
                        ціле починається з цифри 0, воно задає вісімкове число, якщо ж ціле починається з 0х або 0Х тоді
                        це ціле належить шістнадцятковій системі числення.
                        Константи також можуть використовуватись для ініціювання змінних перед початком роботи програми.
                        В Сі це можна зробити в операторі опису. Наприклад:
                        int x=15;
                        float y=0.15; z=243.6;
                        short d; e=54;
                        Відмітимо, що в останній стрічці ініціюється тільки остання змінна e.
                        Зазначимо також, що цілі типу int займають 2 чи 4 машинні слова, цілі типу short або short int -
                        2 слова, цілі типу long або long int - 4 слова.
                    </text>
                </sub_item>
                <sub_item>
                    <item_title>2.3.Беззнакові цілі</item_title>
					<text>
                    Тип беззнакових цілих є модифікатором одного з трьох раніше описаних типів. Тому ми можемо
                    використовувати комбінації ключових слів unsigned int, unsigned long, unsigned short. Деякі
                    обчислювальні системи не забезпечують апаратну реалізацію типу unsigned long, а в деяких unsigned -
                    спеціальний тип фіксованого розміру.
                    Цілі беззнакові константи записуються аналогічно звичайним цілим константам, за виключенням того, що
                    заборонено використання знаку. Використання такого типу змінної по-перше гарантує, що змінна не
                    прийме від’ємного значення і по-друге - вона може прийняти значно більше ціле значення. Традиційне
                    використання беззнакових змінних - адресація пам’яті та організація лічильників в циклах.
					</text>
                </sub_item>
                <sub_item>
					<item_title>
                    2.4.Тип даних char</item_title>
					<text>
                    Цей тип визначає дані які можуть бути розміщені в одному байті пам’яті: наприклад цілі без знака в
                    діапазоні від 0 до 255. В машині використовується спеціальний код для переводу числа в символи і
                    символів в числа. Найбільш поширеними [3] є два коди: ASCII та EBCDIC. Ми будемо використовувати в
                    подальшому розгляді перший код. Важливо пам’ятати що символ числа і саме число це різні речі.
                    Наприклад символу 2 відповідає код ASCII, рівний 50.
                    Символьні константи зображаються трьома способами:
                    1)символом алфавіту взятим в апострофи: ’@’, ’b’, ’4’;
                    2)конструкцією ’\ddd’, де d одна з вісімкових цифр;
                    3)конструкцією вигляду ’\символ’.
                    Тому, що значення типу char займає один байт пам’яті, константи цього типу можуть бути тільки одним
                    символом. Якщо ми поглянемо на таблицю кодів ASCII, тоді побачимо, що деякі із символів не
                    виводяться в ній до друку. Так при використанні в програмі символу номер 7 термінал комп’ютера подає
                    звуковий сигнал. Але як можна використовувати символ який неможливо набрати на клавіатурі? В мові Сі
                    для цього використовуються останні два з вище вказаних форматів.
                    В першому випадку використовується сам код ASCII. Ми повинні тільки вказати номер символу разом з
                    префіксом зворотна похила риска . Наприклад:
                    а=’\007’.
                    Відмітимо, що лідируючі нулі можуть бути пропущені на відміну від нулів закінчення.
                    В другому варіанті задання незручних знаків використовуються спеціальні послідовності символів. Їх
                    називають керуючими послідовностями. Можна виділити найбільш використовувані:
                    ’\n’ - символ нового рядка;
                    ’\t’ - символ вертикальної табуляції;
                    ’\b’ - символ повернення на крок назад;
                    ’\r’ - символ повернення каретки;
                    ’\f’ - символ переведення формату;
                    ’\\’ - символ зворотної похилої;
                    ’\’’ - апостроф;
                    ’\”’- лапки;
                    ’\0’-нуль символ.
                    Розглянемо програму яка дозволяє взнати номер коду символу навіть в випадку, коли на вашій машині
                    використовується код відмінний від ASCII.
                    #include &amp;amp;lt;stdio.h&amp;amp;gt;
                    main()
                    { char ch;
                    printf(”\n”);
                    scanf(”%c,&amp;amp;ch);
                    prinf(“\n\’%c’:%d\n”, ch, ch);
                    }
					</text>
                </sub_item>
                <sub_item>
				<item_title>
                    2.5.Типи даних float i double.</item_title>
					<text>
                    Для більшості обчислювальних програм потрібна точність обчислень що значно більша за ту яку надає
                    тип int. Тому в мові Сі для опису таких змінних використовується тип float. Цей тип дозволяє
                    використовувати числа із значно ширшого діапазону, навіть десяткові дроби. Числа з плаваючою крапкою
                    повністю аналогічні числам в звичайному алгебраїчному запису, який використовується при роботі з
                    дуже великими і малими числами.
                    Алгебраїчна форма запису числа є добутком деякого десяткового числа на степінь, основа якої дорівнює
                    десяти. Наведемо декілька прикладів.
                    Число Алгебаїчний запис Запис введення
                    1000000 = 1.0106 = 1.0е6
                    356000 = 3.56105 = 3.56е5
                    0.007893= 7.89310-3= 7.893е-3
                    Традиційно для розміщення числа з плаваючою крапкою в пам’яті відводиться 32 біти: 8бітів для
                    задання порядку та знаку і 24 біти для мантиси (коефіцієнта при степені десять). Такий споcіб дає
                    можливість задавати числа з точністю до 6-7 десяткових цифр в діапазоні (10-37 -1038 ).
                    В багатьох ЕОМ допускається також обробка даних типу chare (обчислення з подвійною точністю, коли
                    для зберігання числа використовується 64 біти). В деяких ЕОМ всі додаткові 32 біти використовуються
                    для зберігання мантиси. Це збільшує число значущих цифр і зменшує помилку округлення. В інших
                    машинах деяка кількість бітів із додаткового набору використовується для зберігання більшого
                    порядку: це розширює діапазон задання чисел.
                    Інший спосіб опису даних типу chare є використання ключових слів long float.
                    Плаваючі константи складаються з цілої частини, десяткової крапки, дробової частини (послідовності
                    десяткових цифр), символу експоненти е чи Е та показника степеня (цілої константи, можливо, із
                    знаком + або -), У запису константи можуть бути відсутні ціла або дробова частина, але не обидві
                    разом, або крапка чи символ е з показником степеня, але не обидві разом.
					</text>
                    <sub_item>
                        <item_title>2.5.1.Переповнення і втрата значимості при обробці чисел із плаваючою крапкою</item_title>
                        <text>
                        Що трапиться, коли значенню змінної типу float вийдуть за встановлені межі? Наприклад,
                        припустимо, що ми множимо 10е38 на 1000(переповнення) чи ділите 10е-37 на 10000 (втрата
                        значимості). Результат повністю буде залежати від типу ЕОМ яка використовується вами. Наприклад,
                        в одних, при виникненні переповнення результат заміняється максимально допустимим числом, а при
                        втраті значимості - нулем. В інших системах, в подібних ситуаціях можуть видаватись
                        попереджувальні повідомлення, виконання задачі можна призупинити і внести потрібні зміни в
                        програму.
                        </text>
                    </sub_item>
                </sub_item>
              
				<sub_item>
                <item_title>2.6.Символьні стрічки</item_title>
                <text>
				    
                    Символьна стрічка - це послідовність, яка складається з одного або більше символів. Розглянемо
                    стрічку:
                    “Більшість студентів - веселі люди”
                    Лапки тут відіграють роль обмежувачів стрічки. В мові Сі не має спеціального типу для опису стрічок
                    символів. Тому стрічки описуються за допомогою “масиву” елементів типу char. В пам’яті кінець
                    стрічки відмічається нуль-символом \0. Нуль-символ це не цифра 0. Він не виводиться до друку і в
                    таблиці коду ASCII має номер 0. Наявність нуль-символу означає, що кількість комірок масиву повинна
                    бути на одиницю більша за число символів, які потрібно розмістити в пам’яті. Для опису нашої стрічки
                    ми могли б використати такий оператор опису:
                    char name[36];
                    Квадратні дужки вказують, що змінна name - масив, 36- число його елементів, char - задає тип кожного
                    елементу.
                    Розглянемо програму яка демонструє просте використання символьних стрічок.
                    #define praise ”Ваше ім’я прекрасне”
                    main()
                    {
                    char name[30];
                    printf(”Як вас звати?\n);
                    scanf(”%s”, name);
                    printf(”Привіт,%s. %s\n”, name, praise);
                    }
                    Символ %s служить специфікацією друку стрічки. Результат роботи програми може мати таку структуру:
                    Як вас звати?
                    Іван Кравченко.
                    Привіт, Іван. Ваше ім’я прекрасне.

                    Як ви бачите нам самим не прийшлось розміщати нуль-символ в кінець масиву. Ця робота була виконана
                    за нас функцією scanf при читанні вхідної стрічки. praise - ”символьна стрічкова константа”.
                    Директиву define більш детально будемо розглядати пізніше, а поки що зазначимо, що лапки в які взята
                    фраза, що стоїть за стрічковою константою praise, ідентифікують цю фразу як стрічку і тому в її
                    кінець буде розміщено нуль-символ.
                    Відмітимо, що функція scanf() при введенні стрічки ”Іван Кравченко” читає тільки перше слово Іван.
                    Справа в тім, що функція scanf() зустрівши один з розподільників (проміжок, символ табуляції або
                    переводу стрічки) зупиняє введення символів, іншими словами вона присвоює змінній name послідовність
                    символів стрічки введення до першого розподільника. Взагалі, scanf() вводить тільки одиничні слова.
                    Для обробки стрічок загального вигляду в Сі використовується функція gets().
                    В більшості мов програмування для опису булевських значень використовується спеціальний
                    зарезервований базовий тип. В мові Сі такого типу не має. Тут для зображення хибності
                    використовується ціле значення 0, а істина - будь-яке ненульове значення.
					</text>
                </sub_item>
                <sub_item>
                <item_title>2.7.Використання препроцесора для задання констант</item_title>
                <text>
                    
                    Для введення константи в програму достатньо вказати її фактичне значення. Але існують суттєві
                    причини використання в програмі символьних констант. Наприклад, для обчислення довжини кола ми могли
                    б використати оператор с = pidiametr і пізніше компілятор підставив би в нього фактичні значення
                    константи pi 3.14. В чому заключається перевага такого підходу? По-перше, ім’я говорить нам більше
                    ніж число. По-друге, коли потрібно змінити значення константи в програмі, тоді нам потрібно тільки
                    змінити визначення символьної константи, а не відшукувати кожний випадок її появи в програмі.
                    Залишилось вияснити, як можна створити символьну константу? Перший спосіб полягає в тому щоб описати
                    деяку змінну і присвоїти їй значення яке дорівнює потрібній константі. Наприклад:
                    float pi;
                    pi = 3.14;
                    Такий спосіб підходить для невеликої програми. В інших випадках він буде неекономним, оскільки при
                    кожному використанні змінної pi комп’ютер повинен звертатись до частини пам’яті, що відведена під
                    дану змінну. Цей підхід служить прикладом підстановки під час виконання, тому що вона проходить під
                    час виконання програми. Але в Сі є кращий спосіб.
                    Цей підхід базується на використанні препроцесора мови Сі. Для цього, на початок файлу, який містить
                    нашу програму потрібно додати стрічку:
                    #define PI 3.14159
                    Під час компіляції програми коли буде з’являтись змінна PI, вона буде замінятись величиною 3.14159.
                    Цей варіант підстановки називають підстановкою під час компіляції.
                    Декілька зауважень щодо формату. Спочатку йде ключове слово define. Воно повинне починатись з самої
                    лівої позиції. Потім йде символьне ім’я константи, а за ним, через проміжок, її значення. Ім’я PI
                    пишеться прописними літерами щоб можна було відрізнити константи програми від змінних програми, для
                    запису яких використовуються малі символи алфавіту. Але якщо ви використаєте при написанні імені
                    константи символи нижнього регістру - помилки не буде.
                    Якщо ви розробляєте пакет програм, що використовує загальні константи, тоді для економії часу набору
                    тексту програм ви можете використати наступний алгоритм:
                    1.Зберіть всі ваші директиви define в один файл і назвіть його, наприклад, const.h.
                    2.В початок кожного файлу, який містить один із компільованих модулів програми, вставте директиву
                    #include ”const.h”.
					</text>
                    <questions>
						<q_title>
                        Вправи і завдання до розділу 2:
						</q_title>
						<question>
                        <text>2.1. Дослідіть, написавши відповідні програми, як ваша обчислювальна система реагує на
                        переповнення та втрату значимості в базових типах int та float.
						</text>
						<answers>
							<answer>1</answer>
							<answer>2</answer>
							<right>3</right>
							<answer>4</answer>
						</answers>
						</question>
						<question>
                        2. 2. Дослідіть скільки місця в пам’яті займають основні типи даних в Сі на вашій машині.
						</question>
						<question>
                        2.3. Напишіть програму, яка дозволяє взнати номер коду символу, навіть в тому випадку, коли на
                        вашій машині використовується інший від ASCII код.
						</question>
						<question>
                        2.4. Визначте, чи реалізується на вашій машині тип double, і якщо це так, тоді визначте скільки
                        місця в пам’яті ЕОМ займають дані цього типу.
						</question>
						<question>
                        2.5. Напишіть програму, яка визначає кількість букв в вашому прізвищі і кількість байтів для
                        його розміщення в пам’яті. Використайте вмонтовані функції strlen() та sizeof().
						</question>
						<question>
                        2.6. Визначте помилки в програмі:
                        define A-xa-xa
                        define X 10
                        main()
                        { int age;
                        char name
                        printf(” Вкажіть своє ім’я ”);
                        scanf(”%s”,name);
                        printf(”Добре, %c, Скільки вам років?\n”, name);
                        scanf(”%f”, age);
                        xp=age + X;
                        printf(”%s! Вам повинно бути%d.\n”,B,xp);
                        }
						</question>
						<question>
                        2.7.* Дано число у двійковому представлені, довжина якого не перевищує 10000 двійкових розрядів.
                        Необхідно визначити, чи ділеться воно на 15.
						</question>
						<question>
                        2.8.* Знайти кількість одиниць у двійковому запису числа i.
						</question>
						
                    </questions>
                </sub_item>
            </sub_item>

            <sub_item>
			<item_title>3. Операції, вирази та оператори</item_title>
            <text></text>
             <sub_item>
			<item_title>3.1.Операції та вирази</item_title>
            <text>  
                
                Вирази описують процеси породження значень застосуванням операцій над даними [5,6]. Вирази бувають
                різного базового типу: присвоєння, арифметичні, відношення, логічні. Тип виразу і породжуваного ним
                значення визначається операціями і типами операндів до яких застосовуються ці операції.
                Простими виразами, які не містять знаків операцій є імена змінних і констант. Значення константи - це
                відповідний елемент типу до якого вона належить. Значення виразу, що є іменем змінної, це значення
                змінної, тобто з появою імені змінної до нього застосовується операція добути значення . Складніші
                вирази будуються з простих за допомогою операндів, знаків операцій та дужок. Операнди - це константи,
                змінні, покажчики функцій та вирази. Вирази, в яких в Сі первинні складові є константами, називаються
                константними. Значення таких виразів обчислюється під час компіляції і вони вживаються скрізь де
                допустимі константи.
                Порядок виконання операцій у виразах відповідає їх старшинству за відсутності дужок. Операції з
                однаковим пріоритетом у виразах виконуються зліва направо, за винятком унарних операцій, операції
                присвоєння і умовної операції. Операції та їх позначення описує таблиця 3.1..

                Групи операцій Знаки операцій
                Дужки та адресні ( ) [ ] . -&amp;amp;gt;
                Унарні ++ -- (type) ~ ! &amp;amp; * sizeof
                Арифметичні мультиплікативні * / %
                Арифметичні адитивні + -
                Зсуви  
                Відношення І &amp;amp;lt; &amp;amp;lt;= &amp;amp;gt; &amp;amp;gt;=
                Відношення ІІ == !  =
                Побітна кон’юнкція &amp;amp;
                Побітна додавання за mod 2 ^
                Побітна диз’юнкція 
                Логічна кон’юнція &amp;amp;&amp;amp;
                Логічна диз’юнкція 
                Умовна ? :
                Присвоєння = += -= *= /= %= =
                = &amp;amp;= != ^=
                Кома ,

                Таблиця 3.1. Позначення операцій.
                Для означення операцій та виразів введемо такі позначення: e - будь-який вираз, v - змінна, i чи a перед
                e або v - тип виразу або змінної, i - ціле чи символьне, a - арифметичне(тобто ціле, символьне чи
                плаваюче), val(e) або val(v) значення виразу e чи змінної v відповідно.
                Тоді арифметичні вирази можуть мати вигляд:
                ae1 S ae2 або -ae , або ie1 % ie2
                де S - один із знаків операцій +, - , *, /. Їхні значення відповідно: val(ae1) S val(ae2), -val(ae),
                залишок від ділення val(ie1) на val(ae2). Знак результату операції % визначається тільки для додатних
                операндів. При діленні двох цілих ie1/ie2 відкидається дробова частина, і значення виразу є ціле.
                Арифметичними є також вирази збільшення та зменшення: iv++, iv--, ++iv, --iv. Семантика обчислення цих
                виразів така. Якщо val0(iv) i val1(iv) значення змінної iv до та після обчислення значення виразів ++iv
                та iv++, тоді
                val(++iv) = val1(iv) = val0(iv)+1
                val(iv++) = val0(iv)
                val1(iv) = val0(iv)+1.
                Аналогічно вирази iv-- та –iv зменшують значення iv на 1.
                Унарні операції -- та ++ мають рівні пріоритети; вони старші від операцій *, / , % , які мають рівні
                пріоритети, старші від операцій + , - .
                Вирази присвоєння мають вигляд v=e або avS=ae де S-знак операції + , - , * , &amp;amp; ,  , ^ , &amp;amp;lt;&amp;amp;lt;
                , &amp;amp;gt;&amp;amp;gt;) або iv%=ie. Вони викликають небажаний ефект:
                val(v=e) = val(v) = val(e),
                val(av+=ae) = val1(av) = val(av) + ae
                тощо.
                Всі операції присвоєння молодші від арифметичних і мають однакові пріоритети. Побічний ефект виразів
                збільшення-зменшення та присвоєння відображає їхній основний зміст - зміну значень змінних.
                Приклад. Задано опис: int i,j,k; змінні i,j,k мають відповідно значення 5,6,2. Тоді:
                а)val(i*j)=30; val((i+j+1)/k) = 6; val((i+j)%k) = 1;
                б)val(k++) = 2; val(++k) = 3 і в обох випадках новим значенням к буде val(k)=3;
                в)val(k+=2)=4 і новим значенням к буде val(k)=4; аналогічно val(j/=2)=3;
                г)val(k=-(j=i++)) = -5 з новими значеннями i=6; j=5; k=-5;

                Вирази відношення мають вигляд ie1 == ie2, ie1 != ie2, ae1 &amp;amp;lt; ae1 &amp;amp;lt;= ae2 ae2, ae1
                &amp;amp;gt; ae2, ae1 &amp;amp;gt;= ae2 і приймають два значення 1 чи 0. Операції &amp;amp;lt; , &amp;amp;lt;=
                , &amp;amp;gt; , &amp;amp;gt;= молодші від арифметичних, але старші від операції присвоєння.
                Логічні вирази мають вигляд: ! ae, e1  e2, e1 &amp;amp;&amp;amp; e2 де !, , &amp;amp;&amp;amp; -
                відповідно знаки логічних операцій заперечення, диз’юнкції та кон’юнкції. Пріоритет операції ! дорівнює
                пріоритету інших унарних операцій ++, --, -.
                На противагу більшості мов програмування в Сі дозволено досить вільне перетворення типів. Вони
                впорядковані за зростанням: char, short, int, long, float, double; цілі типи також вважаються нижчими
                від беззнакових типів. Перед обчисленням значення виразу його операнди типу char i short перетворюються
                в int, типу unsigned char i unsigned short - в unsigned int, типу float - в double. Якщо після цього
                операція має операнди неоднакових типів, тоді операнд нижчого типу перетворюється в операнд вищого типу;
                операнди типу long та unsigned int - в тип unsigned long.
                У виразах присвоєння значення виразу e перетворюється у значення типу змінної v, до того ж можливе
                зниження типу. В перетвореннях значень типу від double до типу float відбувається округлення; float до
                int відкидається дробова частина без округлення; від вищого цілого до нижчого - відкидаються старші
                розряди значення.
                Крім цих неявних перетворень в виразах можна задавати перетворення явно: вираз вигляду ім’я типу e має
                значенням val(e), перетворене до значення вказаного типу. Операція ім’я типу має однаковий пріоритет з
                іншими унарними операціями.
				</text>
				</sub_item>
			<sub_item>
			<item_title>3.2. Операція присвоєння</item_title>
            <text>

                
                В мові Сі знак рівності = позначає операцію присвоєння. Вона трактується традиційно як і в більшості мов
                програмування, але має певну специфіку. В лівій частині оператора присвоєння може стояти декілька
                змінних розділених знаком =. Присвоєння йде зліва направо. Наприклад в операторі
                х=у=а=3;
                значення 3 присвоюється спочатку,а а потім у і х.
			</text>
			</sub_item>
			
			<sub_item>
			<item_title>3.3. Операції збільшення і зменшення</item_title>
            <text>

                
                Як ми вже зазначали операція збільшення виконує дуже просту дію: вона збільшує значення свого операнду
                на одиницю. Префіксна і постфіксна форми цієї операції відрізняються між собою тільки тим, коли
                проходить збільшення операнду. Спочатку розглянемо подібність вказаних форм а потім їх відмінність.
                Розглянемо програму:
                /*виконання додавання */
                main()
                {
                int ultra=0,super=0;
                while(super &amp;amp;lt; 6 )
                { super++;
                ++ultra;
                printf(”super = %d, ultra = %d\n”, super, ultra);
                }
                }
                Результати роботи програми будуть такими:
                super = 1, ultra = 1
                super = 2, ultra = 2
                super = 3, ultra = 3
                super = 4, ultra = 4
                super = 5, ultra = 5
                Визнаємо, що ми могли отримати такий же результат, використавши два оператори присвоєння традиційного
                вигляду:
                super = super + 1;
                ultra = ultra + 1;
                Ці оператори мають досить простий вигляд. Тому виникає питання: для чого потрібен ще один додатковий
                оператор, не говорячи про два, та ще й в скороченому вигляді? По-перше, компактна форма робить наші
                програми більш наглядними і зручними для розуміння. Наприклад, фрагмент програми перерахунку розміру
                взуття в дюйми може мати вигляд:
                size = 3.0;
                while (size &amp;amp;lt;18.5)
                {foot = SCALE*size +OFFSET;
                printf(”%10.1f %20.2f дюймів \n”, size, foot);
                ++size;
                }
                При такому способі ми ще не скористались всіма перевагами операції збільшення. Ми можемо скоротити даний
                фрагмент так:
                size = 2.0;
                while (++size &amp;amp;lt;18.5)
                {foot = SCALE*size +OFFSET;
                printf(”%10.1f %20.2f дюймів \n”, size, foot);
                }
                Тут ми об’єднали в одному виразі операцію збільшення значення змінної на одиницю і перевірку істинності
                умови в операторі while. Конструкція подібного типу зустрічається настільки часто в мові Сі, що
                заслуговує додаткової уваги.
                По-перше, як вона працює? Дуже просто: значення змінної size збільшується на одиницю, а потім порівнює з
                18.5. Якщо воно менше, тоді виконуються оператори тіла циклу. Після цього змінна size збільшується на 1
                іще один раз і т.д. Цикл повторюється до того часу, поки значення size не стане більшим за 18.5.
                Початкове ініціювання size було змінено з 3.0 на 2.0, для компенсації збільшення змінної size перед її
                початковим використанням. По-друге, такий запис керуючої структури - компактний і з його допомогою можна
                об`єднати в одному виразі два процеси, які керують циклом: перевірку умови та зміну параметру циклу.
                Останнє допомагає програмісту не забувати вводити в програму корекцію параметру циклу.
                Але з використанням операцій збільшення і зменшення треба поводитись обережно. Розглянемо фрагмент
                програми виведення до друку певної кількості цілих чисел і їх квадратів:
                while (num&amp;amp;lt;21)
                { printf (&amp;amp;quot;%10d %10d\n, num*num++);
                }
                Ми друкуємо число num, множимо його саме на себе, щоб отримати квадрат і виводимо це значення, а потім
                збільшуємо num на одиницю. На деяких машинах ця програма буде працювати вірно, але не на всіх. Проблема
                полягає в тому, що при використанні функції printf(), коли визначаються значення, які мають друкуватися,
                обчислення останнього аргументу може бути виконано раніше, і приріст змінної num пройде попередньо до
                визначення першого аргументу. Тому замість можливого варіанту стрічки виводу
                6 36
                може бути надруковано
                7 36.
                Правила мови Сі надають компілятору можливість вибору який з аргументів функції обчислювати першим. Це
                підвищує ефективність роботи компілятора, але може привести і до побічних ефектів, якщо операція
                збільшення (зменшення) виконується над одним із аргументів функції.
                Іншим можливим джерелом неоднозначностей буває оператор такого вигляду:
                ans=num/2+5*(1+num++)
                Проблема полягає в тому, що компілятор може виконати дії не в тому порядку, який чекали ми. Не
                зрозуміло, що буде виконуватись раніше num/2 чи num++.


                Тому при використанні операцій збільшення та зменшення потрібно притримуватись таких правил:
                1. Не використовуйте ці операції до змінної, яка присутня в більш ніж одному аргументу функції.
                2. Не застосовуйте ці операції до змінної, яка входить до виразу більше одного разу.
				</text>
                Вправи і завдання до розділу 3:
                3.1.Написати програму, що видає до друку всі прості числа до 20 та їх квадрати.
                3.2. Мабуть, ви чули історію про великого магната-тирана який обіцяв нагородити вченого за надану йому
                послугу. Вчений показав на шахову дошку і сказав: ’’ Покладіть одне зерно на 1 клітину, 2-на другу, 4-на
                третю, 8- на 4-ту і т.п.’’. Доведіть за допомогою програми в яке скрутне становище потрапив магнат.
                Порівняйте нагороду з врожаєм США (в зернах 7Е14) за рік. Результат виведіть у вигляді таблиці

                Клітина Число зерен Сума зерен Доля від урожаю
                1 1.00Е+00 1.00Е+00 1.43У-15

                3.3. Написати програму, що переводить секунди в хвилини та секунди.
                3.4. Найдіть помилки у програмі
                main()
                {int i=1;float n;
                printf(’Увага . Дроби.”);
                while(i&amp;amp;lt;30)
                n=1/i;
                printf(“%f”,n);
                printf(“The End.”);
                }
			

                3.5.Проаналізуйте програму додавання перших двадцяти додатніх цілих чисел починаючи з одиниці :
                main()
                {int count,sum;
                count=sum=0;
                while (count++&amp;amp;lt;20)
                sum +=count;
                printf(“sum=%d”,sum);
                }
                3.5.1. Змініть програму так, щоб число визначення доданків (20), було змінною, яку б ми могли задавати в
                програмі.
                3.5.2. Зробіть такі зміни, щоб після чергового поновлення суми, програма запитувала чи їй потрібно
                закінчувати обчислення, чи продовжувати додавання нових цілих.
                3.6. Написати програму, яка підраховує кількість введених рядків в стандартному файлі воду-виводу.
                3.7. Написати програму, яка підраховує не пусті символи у стандартному вхідному файлі.
                3.8. Написати програму яка підраховує кількість слів в вхідному стандартному файлі вводу, якщо між
                словами один пропуск. Доробіть її так, щоб вона реагувала на інші розподільники між словами.
                3.9. В програмі є помилки. Уточніть програму, позбавтесь помилок:
                main()
                { int weight, height;
                scanf(&amp;amp;quot;%d , weight, height);
                if (weight &amp;amp;lt; 100)
                if (height &amp;amp;gt;= 72)
                printf(&amp;amp;quot;You are too high\n&amp;amp;quot;);
                else {
                if (height &amp;amp;lt; 72 &amp;amp;&amp;amp; &amp;amp;gt; 64)
                printf(&amp;amp;quot;You are high\n&amp;amp;quot;);
                else
                if (weight &amp;amp;gt; 300 &amp;amp;&amp;amp; !(weight &amp;amp;lt;= 300)
                if (!(height&amp;amp;gt;=48))
                printf(&amp;amp;quot;You are too small\n&amp;amp;quot;);
                else
                printf(&amp;amp;quot;Ideal\n&amp;amp;quot;);
                }
                3.10.* Вводиться N. Необхідно знайти, скількома нулями закінчується число N!=1*2*3*...*N.
                3.11.* Знайти добуток двох чисел a та b, якщо в програмі дозволяється використовувати тільки операції
                додавання одиниці INC, присвоєння та порівняння.


            </sub_item>
            <sub_item>
			<item_title>4. Оператори</item_title>
            <text>
                Оператор є командою комп`ютеру. Вони бувають простими та складними. Прості оператори закінчуються
                символом крапка з комою. Ми вже описували дію операторів опису (char ch), присвоєння (х=у), оператор
                виклику функції (printf(“%d \n”,x)), пустий оператор (;).
                Складні оператори або блоки складаються з одного або більше операторів, які взяті в фігурні дужки.
                Розглянемо основні оператори керування.
			</text>
			<sub_item>
			<item_title>4.1. Оператор IF</item_title>
            <text>
                
                Загальний вигляд умовного оператору if традиційний:
                if (вираз) оператор
                Він використовується для можливого вибору виконання або пропуску оператора в програмах. Традиційно в
                якості виразу використовують умовний вираз, але може бути присутнім довільний вираз (якщо його значення
                рівне нулю, воно вважається хибним, якщо відмінне від нуля - істинним). Якщо вираз справджується, тоді
                виконується оператор, інакше керування передається наступному оператору.
                При виборі альтернативи виконання між двома операторами використовується повна форма умовного оператору
                IF-ELSE. Вона має вигляд:
                if(вираз) оператор1 else оператор2
                Якщо вираз справджується, тоді виконується оператор1, інакше - оператор2. У випадку, коли в якості
                оператору2 використовується ще один умовний оператор IF при ідентифікації належності частини ELSE
                дотримуються правила: ELSE відповідає найближчому IF за винятком використання фігурних дужок.
                Зупинимось на реалізації значення істина в Сі. Нагадаємо, що вираз Сі завжди має значення. Це твердження
                залишається вірним навіть для умовних виразів. Розглянемо програму, в якій визначається значення двох
                умовних виразів:
                main() /* істина і хибність */
                {
                int true, false;
                true = (20&amp;amp;gt;2); /* відношення істинне */
                false = (20==2); /* відношення хибне */
                printf (“true=%d; false=%d \n”, true, false);
                }
                При виконанні програми отримаємо результат:
                true=1 false=0
                Це підтверджує той факт, що в Сі значення істина - це 1, а значення хибність - це 0. Тому ми можемо
                використовувати 1 та 0 в якості перевірочних значень для оператору IF. Але це не зовсім так, тому що всі
                ненульові величини приймаються в якості істина. Тому типову перевірку вигляду
                if (x!=0)
                можна замінити на компактнішу
                if(x).
                Зміст останньої не такий зрозумілий, як першої, але є більш ефективним, тому що при реалізації програма
                потребує меншого числа машинних операцій.
                При запису виразу умовної частини оператору ви повинні застережливо відноситись до використання
                оператору присвоєння типу х=5, тому що це значення завжди буде трактуватись як істина.
                Зазначимо, що в Сі є короткий запис одного із типів оператору IF-ELSE. Він називається умовним виразом і
                використовує операцію умови - ?. Ця операція складається з трьох частин і використовує три операнди.
                Розглянемо її застосування на прикладі знаходження абсолютного значення числа:
                x = (y&amp;amp;lt;0) ? -y : y
                В термінах оператору IF - ELSE цей оператор міг мати вигляд:
                if (y&amp;amp;lt;0) x=-y;
                else x=y
                В загальному вигляді умовний вираз можна описати так:
                вираз1 ? вираз2 : вираз3
                Якщо значення виразу1 - істинне, тоді значенням всього умовного виразу є величина виразу2, інакше
                значенням всього умовного виразу є величина виразу3.
                Умовний вираз зручно використовувати в тих випадках, коли змінній потрібно присвоїти одне з двох
                альтернативних значень, наприклад вибрати максимальне або мінімальне значення:
                max = (a&amp;amp;gt;b) ? a:b;
                Використання умовних виразів не є обов`язковим, але вони більш компактні, ніж відповідні умовні
                оператори (IF-ELSE), і приводять до більш компактного машинного коду.
			</text>
			</sub_item>
			<sub_item>
			<item_title>4.2. Оператори SWITCH та BREAК</item_title>
            <text>
                
                Умовна операція і оператор if-else використовуються у випадку, коли нам потрібно зробити вибір між двома
                варіантами. Це можна зробити використавши конструкцію if - else... if - else. Та в Сі є спеціальний
                оператор switch, який полегшує таку роботу.
                Семантика його така. Керування в програмі передається оператору, в якому в якості мітки використовується
                значення деякого виразу. Потім в процесі виконання програми будуть виконуватись оператори, які
                залишились, поки не трапиться новий перехід. Як вираз, так і мітки повинні мати значення цілого типу
                (допускається і тип char). Мітки повинні бути константами, або константними виразами. Якщо деякому
                значенню виразу не відповідає жодна мітка, керування передається оператору з міткою default (може бути
                відсутнім). В іншому випадку керування передається наступному за switch оператору.
                Оператор switch має такий загальний вигляд:
                switch ()
                {
                case: мітка1:оператор1
                case мітка2: оператор2
                . . .
                case міткаN: операторN
                default : оператор
                }
                Якщо ви знайомі з оператором Паскалю case, тоді можна відмітити, що відмінність його від оператору
                switch полягає в тому, що якщо ви бажаєте, щоб в кожному конкретному випадку використовувався тільки
                відмічений оператор, тоді в операторі switch потрібно використовувати оператор break . Використання
                останнього приводить до виходу із оператору switch і керування передається наступному за ним оператору.
                Розглянемо програму, яка читає з терміналу букву і якщо ця буква А чи Б, тоді друкує назву тварини, яка
                починається з цієї букви, в іншому випадку друкує повідомлення “Важка задача”. Ознакою закінчення циклу
                діалогу є введення символу “#”.
                main()
                { char CH;
                printf(“Введіть букву алфавіту і я скажу”);
                printf(“назву тварини, \n яка починається з неї.\n”);
                while((ch=getcher())!=`#’) /* аналогічно паскалівському */
                { /* поки не # - читати символ */
                if(ch!=`\n`) /* пропуск символу нова стрічка */
                {
                if(ch &amp;amp;gt;= `а` &amp;amp;&amp;amp; &amp;amp;lt;=`я`) /* дозволені тільки малі букви */

                switch (ch)
                {

                case `a`: printf(“Аргалі, дикий азіатський баран \n”);
                break;
                case `б`: printf(“Бабіруса, дика малайська свиня \n”);
                default : printf(“Важка задача \n”);
                }
                else
                printf(“Я розумію тільки маленькі букви \n”);
                printf(“Введіть наступну букву чи `#` \n”);
                } /* кінець IF, який пропускає cимвол нова стрічка */
                } /* кінець циклу WHILE */
                }
                Наша програма буде однозначно реагувати (друкувати тільки одне повідомлення) на введений символ. Якщо ми
                видалимо всі оператори break з програми, тоді при вводі символу `а` ми отримаємо друк всіх повідомлень.
                Коли ж ми хочемо отримати однакові результати при переході до різних міток, ми можемо використовувати
                мітки без операторів. Наприклад фрагмент програми:
                case `C`:
                case `c`:
                printf(“слон африканський.\n”);
                break;
                говорить про те, що вказівка букв `С` і `с` приведе до друку назви слон африканський . Якщо введена `С`,
                то пройде перехід до мітки `с`, але оскільки там оператори відсутні, будуть виконуватись оператори, які
                знаходяться нижче, поки не зустрінеться оператор break.
			</text>
			</sub_item>
			<sub_item>
			<item_title>4.3. Оператор while</item_title>
            <text>
                
                Оператор while визначає операції, які циклічно виконуються до того моменту, поки вираз, який стоїть
                після while, стане хибним. Цей оператор називається оператором циклу з передумовою; рішення про чергове
                виконання тіла циклу приймається перед початком його проходження. Тому можлива ситуація, коли тіло циклу
                може бути не виконаним жодного разу. Форма запису оператору така:
                while (вираз) оператор.
                Прикладом використання оператору може служити програма, яка вгадує задумане вами ціле число. В основу
                програми покладено алгоритм бінарного пошуку.
                #include &amp;amp;lt;stdio.h&amp;amp;gt;
                #define HIGH=100 /* верхня межа інтервалу */
                #define LOW=1 /* нижня межа інтервалу */
                main()
                { int guess=(HIGH+LOW)/2;
                int highest=HIGH;
                int lowest=LOW;
                char responce;
                printf(“Задумайте число від %d до %d.
                Я спробую”,LOW,HIGH);
                printf (“вгадати його.\n. Дайте відповідь `д`, якщо моя здогадка вірна”);
                printf (“`б`, якщо \n більше, і `м`, якщо”);
                printf (“менше\n”);
                printf (“Так ... ваше число %d?\n”, guess);
                while ((response=getchar())!=`д`)
                { if (responce != `\n`)
                {if (responce == `б`) highest=guess-1;
                guess=(highest+lowest)/2;
                printf(“Е... надто велике. Тоді ваше число %d?\n”,guess);
                else if (response ==`м`)
                {
                lowest=guess+1;
                guess= (highest+lowest)/2;
                printf(“Е...надто мале.
                Тоді ваше число %d?\n”,guess);
                }
                else {
                printf(“Я не розумію. Введіть будь-ласка `д`,`б`”);
                printf(“або `м`.\n”);
                }
                }
                }
                Зазначимо, що програма буде вірно знаходити число, коли користувач буде правильно давати відповідь: `д`,
                `б`, `м`. Якщо ж він буде робити помилки, тоді і відповідь буде не вірною. Можна було б поставити захист
                від помилок такого типу. Не складно підрахувати, що алгоритм забезпечує вгадування за сім спроб любого
                числа в діапазоні від 1 до 2 7-1. Отже число спроб для знаходження числа із діапазону від 1 до 100 не
                повинна перевищувати 7. Аналогічні роздуми можна провести і для інших інтервалів.
			</text>
			</sub_item>
             <sub_item>
			<item_title>4.4. Oператор for</item_title>
            <text>   
                При організації циклу, коли його тіло повинно бути виконане фіксоване число разів ми повинні реалізувати
                три операції: ініціювання лічильника, порівняння його з певним значенням межі і збільшення (зменшення)
                лічильника при кожному проходженні циклу. В Сі є спеціалізований оператор циклу типу for, в якому
                органічно поєднано організацію цих трьох операцій.
                В операторі for використовуються три вирази, що керують роботою циклу. Вони розділені символом ; .
                Початковий вираз обчислюється тільки один раз до початку виконання одного з операторів циклу. Якщо
                вираз-перевірка буде істинним (не рівним нулю), тіло циклу виконається один раз. Потім обчислюється
                величина виразу корекції і визначається знову величина виразу-перевірки. Оператор циклу for - оператор з
                передумовою, отже знову ж може трапитися, що тіло циклу не виконається жодного разу. Він має таку форму:
                for (ініціювання; перевірка умови; корекція) оператор;
                Тіло циклу виконується так довго, поки вираз-перевірка не стане хибним (рівним нулю).
                Продемонструємо використання циклу в програмі друку кубів цілих чисел від 1 до 6.
                main()
                { int num;
                for (num=1; num&amp;amp;lt;=6; num ++)
                printf (“%5d %5d \n”, num, num*num*num);
                }
                Із першого рядка циклу ми дізнаємось, що початкове число num дорівнює одиниці, кінцеве значення - шести
                (num&amp;amp;lt;=6) і приріст num дорівнює одиниці (num ++).
                Цикл for часто використовується в програмі для тимчасових затримок, пов`язаних з необхідністю погодження
                швидкості реагування машини і можливістю сприйняття людиною:
                for (n=1; n&amp;amp;lt;=1000; n++)
                ;
                Цей оператор примушує машину рахувати до 1000, не виконуючи жодної дії, тому що в якості оператора тіла
                циклу стоїть пустий оператор.
                В операторі for можуть бути реалізовані різні семантичні дії. Визначимо основні з них:
                1. Можна організувати ітерацію з від`ємним кроком:
                for (n=10; n&amp;amp;gt;0; n--)
                printf (“%d секунд! \n”,n);
                printf (“%d запуск! \n”);

                2. Можна реалізувати різний крок циклу:
                for (n=5; n&amp;amp;lt;60; n+=10)
                printf (“%d \n”,n);
                В цьому операторі значення n буде збільшуватись кожний раз на 10 і в результаті будуть надруковані числа
                5, 15, 25, 35, 45, 55.

                3. Можна вести підрахунок за допомогою символів, а не тільки чисел:
                for (ch=`a`; ch=`z`; ch++)
                printf (“Величина коду ASCII для %с дорівнює %d/ \n”, ch, ch);

                При виконанні цього оператору будуть друкуватись всі букви від a до z разом з їх кодами в ASCII. Цей
                оператор працює оскільки символи в пам`яті машини розміщуються у вигляді чисел і тому в даному
                фрагменті, насправді, рахунок ведеться з використанням цілих чисел.
                4. Можна перевірити виконання деякої специфічної умови, відмінної від умови, яка визначає число
                ітерацій:
                for ( num=1; num*num*num&amp;amp;lt;=216; num++)
                Такий тип оператора for використовується у випадку, коли нас цікавить виконання якоїсь умови, а не
                кількість ітерацій (аналогічно оператору while).

                5. В якості операції корекції параметру циклу може виступати не тільки операція додавання. Третім
                виразом в операторі for може використовуватись довільний правильний вираз, і його значення буде
                змінюватись на кожному кроку ітерації:
                for (x=1; y&amp;amp;lt;=75; y=5*x++ +10);
                printf (“%10d %10d \n”, x, y);
                Зверніть увагу, що в специфікації перевіряється значення y, а не x. В кожному із трьох виразів оператору
                for, можуть використовуватись довільні змінні. Але такий стиль програмування буде поганим. Програма
                виглядає значно зрозумілішою. коли ми не змішуємо процес зміни параметру циклу з алгебраїчними
                обчисленнями.

                6. Наявність кожного з трьох виразів не обов`язкова. Повинні бути присутніми символи “;” і оператори,
                які кінець кінцем приведуть до закінчення роботи циклу:
                ans=2;
                for (n=3; ans&amp;amp;lt;=25;)
                ans*=n;
                Тіло циклу
                for (; ;)
                printf (“Я хочу щось зробити \n”);
                буде виконуватись нескінченно, тому, що пуста умова завжди вважається істинною.

                7. Перший вираз не повинен обов`язково ініціювати змінну. Але необхідно пам`ятати. що перший вираз
                виконується тільки один раз на початку роботи циклу:
                for (printf (“Запам`ятовуйте введені числа! \n”); num==6;)
                scanf (“%d”,&amp;amp; num);
                В цьому фрагменті друкується повідомлення, а потім вводяться числа. Умовою закінчення введення є
                введення числа 6.

                8. Параметри які вводять в три вирази специфікації циклу, можна змінювати при виконанні операції в тілі
                циклу.
                Великий вибір вигляду виразів, які керують роботою циклу for, дозволяють за допомогою цієї конструкції
                робити значно більше, ніж просто організовувати ітераційний процес. Можливості циклу for можуть бути
                значно розширені шляхом використання операцій, які ми зараз розглянемо.
			</text>
			</sub_item>
			<sub_item>
			<item_title>4.5. Oперація кома</item_title>
            <text>   
                
                Ця операція збільшує потужність використання циклу for, дозволяючи включати в його специфікацію декілька
                виразів. Операція кома використовується не тільки в операторі for, але тут вона використовується
                найбільше. Операція наділена також однією особливою властивістю: при її використанні гарантується, що
                вирази, в яких вона застосовується (тобто вирази, розділені комою) будуть оброблятись зліва направо.
                Символ кома може використовуватись і в якості розподільника. Тому коми в операторах
                char ch, date;
                або
                printf (“%d %d \n”, x, y);
                є розподільниками, а не знаками операції кома.
                Розглянемо, як за допомогою операції кома можна вирішити парадокс Зенона. Грецький філософ говорив, що
                випущена стріла ніколи не досягне цілі. Мотивація була така. Спочатку, казав він, стріла пролетить
                половину віддалі до цілі. Після цього їй залишиться пролетіти половину всієї відстані, але спочатку вона
                повинна буде пролетіти половину того, що їй залишилось пролетіти і т.д. до нескінченності. Оскільки
                відстань польоту розбита на нескінченне число частин, для досягнення цілі стрілі потрібен буде
                нескінченний час.
                Застосуємо кількісний підхід і припустимо, що за одну секунду польоту стріла пролітає першу половину
                відстані. Тоді за наступні 1/2 секунди вона пролетить половину того, що залишилось від половини, за 1/4
                секунди - половину того, що залишилось після цього, і т.д. Тоді повний час польоту задається сумою
                нескінченного ряду
                1 + 1/2 + 1/4 + 1/8 + . . .
                Можемо написати програму для знаходження перших декількох членів.
                #define LIMIT 15
                main()
                { int count;
                float sum,x;
                for (sum=0.0, x=1.0, count=1; count&amp;amp;lt;=LIMIT; count++, x*=2.0)
                { sum+=1.0/x;
                printf (“sum=%f коли count=%d. \n”, sum, count);
                }
                }
                В результаті виконання програми отримаємо значення сум, які відповідають першим 15 членам ряду :
                sum=1.000000 коли count=1
                sum=1.500000 коли count=2
                . . .
                sum=1.999756 коли count=13
                sum=1.999878 коли count=14
                sum=1.999939 коли count=15
                Можна побачити, що не дивлячись на те, що ми додаємо нові члени, сума прямує до деякої границі. Дійсно,
                математиками було показано, що при прямуванні числа членів до нескінченності сума ряду прямує
                (сходиться) до 2.0, що й демонструється нашою програмою.
			</text>
			</sub_item>
			<sub_item>
			<item_title>4.6. Цикл do while</item_title>
            <text>  
                
                Для багатьох обчислювальних задач корисним є використання циклу з постумовою (умовою на виході). В цьому
                випадку тіло циклу обов`язково виконається як мінімум один раз. В Сі такий оператор циклу реалізується
                конструкцією do while. Взагалі цикл має вигляд:
                do оператор while (вираз);
                Проілюструємо його виконання таким прикладом:
                do
                { ch=getchar();
                putchar(ch);
                } while (ch!=`\n`)
                Такий запис буде значно відрізнятись від запису:
                while ((ch=getchar()) !=`\n`)
                putchar(ch);
                Відмінність починається з того моменту, де стоїть символ `\n`. Цикл while друкує всі символи до моменту
                появи символу `\n`, а цикл do while - всі символи, включаючи і символ ’\n’.
			</text>
			</sub_item>
			<sub_item>
			<item_title>4.7. Оператори керування break, continue, goto</item_title>
            <text>
                
                Оператор break може використовуватись або в операторі switch або в одному із операторів циклу. При його
                досягненні проходить вихід із конструкції, в якій він знаходиться і передача керування наступному
                оператору програми.
                Одне із традиційних використань break полягає в організації виходу із циклу, коли потрібно реалізувати
                дві різні умови закінчення його роботи. Розглянемо цикл:
                while ((ch=getchar()) !=EOF)
                {
                if (ch==`\n`)
                break;
                putchar(ch);
                }
                Він реалізує ехо-друк введених символів, зустрівши при читанні або символ EOF (кінець файлу) або символ
                “нова стрічка”.
                Якщо ви з`ясуєте, що break входить в оператор if, спробуйте змінити цю умову таким чином, щоб її
                використання відпало. В нашому випадку оператор циклу може бути переписаний в такому вигляді:
                while ((ch=getchar()) !=EOF &amp;amp;&amp;amp; ch!=`\n`)
                putchar(ch);
                Оператор continue використовується тільки в операторах циклу. Досягнення оператору continue в тілі циклу
                викликає пропуск тієї частини тіла циклу, яка стоїть після оператору continue і перехід до наступного
                кроку ітерації. Так, наприклад, його використання в попередньому операторі while замість оператору
                break, у випадку його досягнення, буде викликати пропуск друку символу `\n`.
                Оператор безумовної передачі керування goto можна зовсім не використовувати, але він реалізований в Сі.
                Так творці Сі вважали оператор goto “надзвичайно поганим” засобом і закликали використовувати його
                якомога менше.
                Виконання оператору goto викликає передачу керування в програмі оператору, відміченому вказаною міткою.
                Для відокремлення оператора від приписаної йому мітки використовується двокрапка. Ім`я мітки повинно
                бути ідентифікатором. Відмічений оператор може текстуально з`явитися в програмі до або після оператора
                goto. Форма запису оператору такa:
                goto мітка;
                . . .
                мітка: оператор
                Існує тільки один випадок. коли використання оператору goto допускається досвідченими програмістами - це
                вихід із вкладеної структури набору циклів при з`ясуванні якихось помилок, тому що використання
                оператору break дає можливість виходу тільки із самого внутрішнього циклу. Наприклад:
                while (funct&amp;amp;gt;0)
                { for (I=1; I&amp;amp;lt;100; I++)
                { for (J=1; J&amp;amp;lt;=50; J++)
                { . . .
                Велика кількість операторів;
                . . .
                if () goto help;
                . . .
                Оператори;
                . . .
                }
                . . .
                Велика кількість операторів;
                . . .
                }
                . . .
                Велика кількість операторів;
                . . .
                }
                . . .
                Оператори
                . . .
                help: Виправлення помилки; }
			</text>
                Вправи і завдання до розділу 4:
                4.1. Hаписати пpогpаму, яка б виводила до дpуку наступну фiгуpу,
                $
                $$
                $$$
                $$$$.
                4.2. Розpобiть алгоpитм i пpогpаму, яка б дозволила малювати символами дpуку фiгуpи такого вигляду.
                -------------------
                ...................
                ...................
                ============================
                ||||||||||||||||||
                |||||||||||||||||||
                ||||||||||||||||||||
                ||||||||||||||||||
                ||||||||||||||||||
                //////////////////
                |||||||||||||||

                4.3. Що надpукує наступна пpогpама?
                #define PRINT(int) prinf(&amp;amp;quot;int=%d\n&amp;amp;quot;,int)
                #include&amp;amp;lt;stdio.h&amp;amp;gt;
                main()
                {int x,y,z;
                x=03; y=02; z=01;
                PRINT(x|y&amp;amp;z);
                PRINT(x|y&amp;amp;~z);
                PRINT(x^y&amp;amp;~z);
                PRINT(x&amp;amp;y&amp;amp;&amp;amp;z);
                x=1; y=-1;
                PRINT(!x|x);
                PRINT(~x|x);
                PRINT(x^x);
                x&amp;amp;lt;&amp;amp;lt;=3; PRINT(x);
                y&amp;amp;lt;&amp;amp;lt;=3; PRINT(y);
                y&amp;amp;gt;&amp;amp;gt;=3; PRINT(y);
                }

                4.4. Напишіть пpогpаму, яка дpукує кількість входжень кожної цифpи, невидимих символiв i iнших символiв
                в файл.
                4.5. Hаписати пpогpаму яка читає вхiдний файл i видає найдовшу стpiчку в ньому.
                4.6.* 9. Дано натуральні числа a та b. Знайти d = НСД(a, b) та такі цілі числа x та y, що d = a * x + b
                * y.


            </sub_item>
           
			</sub_item>
			<sub_item>
			<item_title>5. Використання функцій в Сі</item_title>
            <text></text>
              <sub_item>
			<item_title> 5.1. Причини використання функцій</item_title>
            <text>
                
               
                Як і для чого використовуються системні функції ми вже розглядали. Але ми хочемо створити свої функції,
                які можна було б використовувати в різних програмах. Для чого потрібні функції?
                По-перше, вони дозволяють не переписувати декілька раз програмування повторних дій програми. Якщо якусь
                дію потрібно в програмі виконувати декілька раз, потрібно написати відповідну функцію тільки один раз, а
                потім будемо викликати стільки раз скільки буде потрібно.
                По-друге, ми можемо використовувати одну функцію в різних програмах. І на кінець, використання функцій
                підвищує рівень модульності програми і тому полегшує її читабельність, внесення змін і корекцію помилок.
                Припустимо, ми хочемо написати програму для реалізації такої послідовності дій:
                - ввести множину чисел;
                - впорядкувати їх;
                - знайти їх середнє арифметичне;
                - надрукувати гістограму
                Тоді структура відповідної програми буде мати вигляд:
                main()
                {float list [50];
                readlist(list);
                sort(list);
                average(list);
                bargraph(list);
                }
                Зрозуміло - що ми ще повинні запрограмувати чотири функції readlist(), sort(), average(), bargraph(),
                але порядок вирішення задачі ми вже задали. Використовуючи мнемоніку імен функцій, ми чітко визначаємо,
                що програма повинна робити і як вона організована. Опісля, можна займатись кожною функцією окремо і
                підлагоджувати її окремо до того часу, поки вона не стане правильно виконувати потрібну задачу.
                Додаткова перевага цього підходу полягає в тому, що якщо ми створюємо функції достатньо загального типу,
                тоді їх можна буде використовувати і в інших програмах.
                Отже переваги застосування функцій ми вже описали. Тепер з’ясуємо, що ж нам потрібно знати про функції?
                Нам потрібно встановити: як визначаються функції, як можна звертатися до них, як встановлювати зв’язок
                між функцією і програмою, яка її викликає. Для вивчення цих питань розглянемо простий приклад, а потім
                будемо узагальнювати його, ввівши додаткові характеристики.
                Створимо функцію, яка друкує 65 символів  в одному рядку. Щоб ця функція виконувалась в деякому
                контексті, будемо використовувати її в програмі, яка друкує титул фірмового бланку. Відповідно програма
                буде складатись із функції main() і starbar():
                / титул фірмового бланку, версія 1/
                #define NAME “ТЕТРА-ЛТД”.
                #define ADDRESS ”Боярка. Молодіжна 1”
                #define PLACE “ Україна. Київська область”
                main()
                { starbar();
                printf(“% s\n”, NAME);
                printf(“% s\n”, ADDRESS);
                printf(“% s\n”, PLACE);
                starbar();
                }
                /  опис функції starbar()  /
                #include &amp;amp;lt;stdio.h&amp;amp;gt;
                #define LIMIT 65
                starbar();
                { int count;
                for (count=1; count&amp;amp;lt;=LIMIT;count++)
                putchar(‘’);
                putchar(‘\n’);
                }

                Результат роботи буде такий:
                ************************************************************
                ТЕТРА-ЛТД
                Боярка. Молодіжна 1.
                Україна. Київська область.
                ************************************************************
                Звернемо вашу увагу на такі моменти:
                1. Ми викликали функцію starbar() із функції main(), використавши тільки її ім’я. Помістивши після нього
                крапку з комою ми перетворили його в оператор-функцію. Це одна із форм виклику функції, але існують і
                інші форми. Коли в процесі виконання програми, комп’ютер досягне оператору starbar(), він знайде
                потрібну функцію і почне виконувати команди, які знаходяться в ній. Після закінчення, керування
                передається наступній команді в програмі виклику.
                2. Структура функції повністю співпадає з структурою написання головної програми.
                3. Ми включали starbar() і main() в один файл, але можна було б створити і два файли. Перший варіант
                полегшує компіляцію, а другий дає можливість використання функції в різних програмах.

				</text>
				</sub_item>
              <sub_item>
			<item_title> 5.2. Аргументи функції</item_title>
            <text>
                
                Титул фірмового бланку виглядав би краще, якщо б текст був зсунутий до центру. Це можна зробити,
                надрукувавши певну кількість проміжків перед виведенням потрібного рядка. Використаємо функцію space() з
                цією метою. Ми повинні забезпечити такий її зв’язок з головною програмою, щоб та могла замовляти функції
                потрібну кількість проміжків. Розглянувши наш текст, приходимо до висновку, що для вирішення поставленої
                задачі ми повинні зсунути текст повідомлення на 25 проміжків. Для передачі функції значення 25 будемо
                використовувати її аргумент в вигляді space(), додавши до попередньої програми відповідний опис.

                {int spaces;
                starbar();
                space(25) / використовує константу в якості аргументу /
                printf(“%s”, NAME);
                spaces=(65-strln(ADDRESS))/2; /скільки потрібно пропустити
                проміжків/
                space(spaces); / аргумент-змінна /
                printf(“%s\n”, ADDRESS);
                space((65-strln(PLACE))/2); / аргумент-вираз /
                printf(“%s\n”, PLACE);
                starbar();
                }
                / визначення функції starbar()/
                . . .

                / визначення функції space()/
                space( number )
                int number; / аргумент описується перед { /
                / початком тіла функції /
                { int count;
                for (count=1; count&amp;amp;lt;=number; count++)
                putchar(‘ ’);
                }
                Перша стрічка програми інформує компілятор, що функція space() має аргумент і його ім’я number. Друга
                стрічка, опис int number, вказує компілятору, що аргумент number має тип int. Такий опис можна було б
                поєднати і в одній стрічці:
                space( int number )
                Незалежно від форми запису, змінна number називається формальним параметром або формальним аргументом.
                При виклику функції формальний параметр заміняється фактичним аргументом. Фактичний аргумент  конкретне
                значення, яке присвоюється цій змінній в програмі-виклику. Фактичний аргумент може бути константою,
                змінною і більш складним виразом. Незалежно від типу фактичного аргументу, він спочатку вираховується, а
                потім його величина передається функції.
                Якщо функція має декілька формальних аргументів, тоді їх можна описати, розділивши комою. Наприклад:
                print num(i,j)
                int i,j;
                { printf(“Нових точок =%d. Всього точок =%d\n ”,i,j);
                }.
				</text>
				</sub_item>
              <sub_item>
			<item_title> 5.3. Оператор return  оператор повернення значення функцією</item_title>
            <text>
                
                Розглянемо функцію, яка обчислює абсолютну величину числа і протестуємо її на декількох конкретних
                значеннях, які задаються в головній програмі.
                main()
                { int a=10, b=0,c=22;
                int d,e,f;
                d=abs(a);
                e=abs(b);
                f=abs(c);
                printf(“%d %d %d\n”,d,e,f);
                }
                / функція abs() /
                abs(x)
                int x;
                { int y;
                y=(x&amp;amp;lt;0)?x : x;
                return (y);
                Результат роботи програми буде стрічка:
                10 0 22
                Ключове слово return вказує на те, що значення виразу, який стоїть в дужках після нього, буде присвоєно
                функції в тілі якої знаходиться оператор return . Тому після виклику abs(a) значенням abs(a) буде 10,
                яке потім присвоюється змінній d.
                Оператор return виконує ще одну дію. Він завершує виконання функції ( де б він не стояв ) і передає
                керування наступному оператору в програмі, яка викликає відповідну функцію. Тому функцію abs() ми могли
                описати так:
                abs(x)
                int x;
                {
                if (x&amp;amp;lt;0) return (x);
                else return (x)
                }
                Остання версія функції abs() простіша, бо в ній не використовується додаткова змінна y. Але обидві
                реалізації однакові, бо мають однаковий вхід і забезпечують тотожній вихід. Навіть наступна версія
                функції abs() буде працювати аналогічно:
                abs(x)
                int x;
                {
                if (x&amp;amp;lt;0) return (x);
                else return (x)
                printf (“ Професор Оленак  дивак. \n”);
                }
                Наявність операторів return у двох можливих гілках виконання програми ніколи не дозволять виконати
                оператор printf і професор Оленак, який буде в своїх цілях використовувати об’єктний код цієї програми
                ніколи не здогадається ( якщо він не вміє читати об’єктний код ) про дійсні почуття свого
                студента-програміста.
                Ми також можемо використовувати оператор return без параметрів. В цьому випадку функція завершує свою
                роботу і передає керування наступному оператору в програмі-виклику.

				</text>
				</sub_item>
              <sub_item>
			<item_title> 5.4. Змінні</item_title>
            <text></text>
                <sub_item>
			<item_title> 5.4.1. Локальні змінні</item_title>
            <text>
                
                Ми вже зазначали, що змінні в функції є її внутрішніми змінними і не відомі ззовні. Тому для зв’язку між
                функціями ми використовуємо аргументи і оператор return .
                Змінні, які відомі тільки одній функції (яка їх містить), називаються локальними змінними.
                Але в мові Сі можливий варіант використання змінних, які відомі декільком функціям. Такі нелокальні
                змінні називаються глобальними і ми повернемось до них пізніше.
				</text>
				</sub_item>
				<sub_item>
				<item_title> 5.4.2. Знаходження адреси : операція &amp;amp;</item_title>
				<text>
                
                Результатом виконання операції &amp;amp; є адреса комірки пам’яті, яка відповідає змінній, що
                знаходиться після знаку операції. Так, якщо xзмінна, тоді &amp;amp;xїї адреса в пам’яті.
                Наприклад, якщо ми маємо оператор int x=25; і компілятор забезпечив її розміщення в пам’яті за адресою
                1000002, тоді в результаті виконання оператора printf(%d %d. \n”,x,&amp;amp;x) отримаємо
                25 1000002 . Зауважимо ще раз, що в мові Сі кожна функція використовує свої власні змінні.
				</text>
				</sub_item>
				<sub_item>
				<item_title> 5.4.3. Зміна змінних в програмі виклику</item_title>
				<text>
                
                Для багатьох задач потрібне таке використання функцій, при якому вона могла б змінити значення змінних в
                якійсь іншій функції. Розглянемо приклад.
                main() / переприсвоєння змінних /
                {
                int x=5,y=10;
                printf(“ Спочатку x=%d і y=%d. \n”,x,y);
                interchange (x,y); / значення x присвоїти значення y і навпаки /
                printf(“ Зараз x=%d і y=%d. \n”,x. y);
                }
                interchange (u,v)
                int u,v;
                { int temp;
                temp=u;
                u=v;
                v=temp;
                }
                і спробуємо перевірити виконання. Після запуску програми на виконання матимемо:
                Спочатку x=5 і y=10.
                Зараз x=5 і y=10.
                Значення змінних не помінялось місцями! Вставимо в функцію interchange декілька операторів друку для
                з’ясування причин помилки
                interchange ( u,v )
                int u,v;
                { int temp ;
                printf(“ Спочатку x=%d і y=%d. \n”,x,y);
                temp=u;
                u=v;
                v=temp;
                printf(“Зараз u=%d і v=%d. \n” , u, v)
                }
                Результат роботи програми на цей раз буде такий
                Спочатку x=5 і y=10
                Спочатку u=5 v=10
                Зараз u=10 v=5
                Зараз x=5 y=10
                Звідки видно, що функція працює вірно, а помилка з’являється при передачі результатів обробки в функцію
                main(). Як ми вже зазначали, функції main() i interchange() використовують різні змінні, тому зміна
                значень u i v ніяк не впливає на значення змінних x i y. Використати оператор return() також неможливо,
                тому що він може передати в програму-виклик тільки одне значення. Тому нам залишається тільки один вихід
                 використати покажчик .
				</text>
				</sub_item>
				</sub_item>
				<sub_item>
				<item_title> 5.5. Перше знайомство з покажчиками</item_title>
				<text>
                
                
                Покажчик  деяке символьне задання адреси. Ми вже використовували таке позначення раніше. Так &amp;amp;x
                позначає “покажчик на змінну x”. Фактична адреса  це число ( в нашому випадку 1000002), а символьне
                задання адреси &amp;amp;x є константою типу покажчик. Після цього стає зрозумілим, що адреса комірки,
                яка відводиться якійсь змінній в процесі виконання програми не змінюється.
                В мові Сі є і змінні типу покажчик. Значенням змінної типу покажчик буде адреса деякої величини. Якщо ми
                змінній такого типу
                ( будемо називати покажчик ) дамо ім’я ptr ( скорочення від pоinter), тоді ми можемо написати такий
                оператор:
                ptr=&amp;amp;x; / присвоює адреси x змінній ptr /
                і будемо говорити в цьому випадку, що ptr вказує на x. Відмінність між ptr і &amp;amp;x полягає в тому,
                що ptr  змінна, а &amp;amp;x  константа. В будь-який момент ми можемо змінити значення ptr, наприклад
                ptr=&amp;amp;y.
				</text>
				</sub_item>
				<sub_item>
				<item_title> 5.5.1.Операція неявної адресації</item_title>
				<text>
                
                Припустимо, що ми знаємо, що змінна ptr є покажчиком. Тоді для доступу до значення, яке міститься за
                адресою, на яку вказує покажчик ptr, можна скористатися операцією неявної адресації (). Наприклад, якщо
                ptr = &amp;amp;y, тоді оператор
                val = ptr;
                буде еквівалентний
                val=y.
				</text>
				</sub_item>
				<sub_item>
				<item_title> 5.5.2. Опис покажчиків</item_title>
				<text>
                
                Враховуючи, що для деяких операцій, пов’язаних з покажчиками, потрібно знати об’єм відведеної пам’яті,
                опис покажчиків має вигляд:
                описувач типу  ім’я-покажчика;
                Наприклад:
                int *pi; /* покажчик на змінну цілого типу */
                char *pc; /* покажчик на змінну символьного типу */
                Що можна сказати більше про останній оператор? pc є покажчиком на змінну char. Її величина є адресою, -
                це ціле число без знаку, тому друкуючи значення змінної pc, ми будемо використовувати формат %u.
				</text>
				</sub_item>
				<sub_item>
				<item_title> 5.5.3. Використання покажчиків для зв’язку між функціями</item_title>
				<text>
                
                Повернемось до програми, яка реалізує обмін значеннями між двома змінними.
                main() /  обмін, 3-я версія /
                {
                int x=5,y=10;
                printf (“Спочатку x=%d і y=%d. \n”,x,y);
                interchange(&amp;amp;x,&amp;amp;y); / Передача адрес /
                printf (“x=%d і y=%. \n”,x,y);
                }
                interchange(u,v);
                int *u,*v; /* u і v є покажчиками */
                { int temp;
                temp=*u; /* temp присвоюється значення на яке */
                / * вказує покажчик u */
                *u=*v;
                *v=temp;
                }
                і, після запуску на виконання, будемо мати:
                Спочатку x=5 y=10
                Зараз x=10 y=5
                Отже ми вирішили поставлену задачу змінити значення змінних x та y. Шляхом передачі функції адрес
                змінних x і y ми дали їй можливість доступу до них. Використовуючи покажчик і операцію *, функція змогла
                дістати значення, які були розміщені у відповідні комірки пам’яті, і помінять їх місцями.
				</text>
				</sub_item>
				</sub_item>
				<sub_item>
				<item_title> 5.6. Передача інформації про змінну</item_title>
				<text>
                
                
                Взагалі, при виклику функції інформація про змінну може передаватись функції двома способами:
                1) function1(x) - передача значення змінної x;
                2) function2(&amp;amp;x) - передача адреси змінної x.
                Перша форма звертання вимагає, щоб визначення включало в себе формальний аргумент того ж типу, що й x:
                function1(num)
                int num;
                Друга форма звертання до функції вимагає формальний аргумент, який є покажчиком на об’єкт потрібного
                типу:
                function2(ptr)
                int *ptr.
                Перша форма використовується, коли вхідне значення потрібно функції для обчислень або дій, а друга форма
                - коли функція повинна міняти значення змінних в програмі-виклику. Традиційне використання другої форми
                - це застосування функції scanf() для введення значень змінних. Так, коли ми хочемо ввести значення
                змінної num цілого типу, ми повинні написати scanf(“%d,&amp;amp; num”). Згідно такого оператору,
                вводиться ціле значення для змінної num і воно розміщується в пам’яті за адресою &amp;amp;num.
                Якщо порівняти з використанням функції в Паскалі, тоді перша форма відповідає роботі з параметром
                значенням, а друга - з параметром змінною.
                При написанні програми ми розглядаємо змінну, як об’єкт, який має найменше два атрибути: ім’я і
                значення. Після компіляції програми і завантаження в пам’ять “з точки зору машини” дана змінна має також
                два атрибути: адресу і значення. Адреса  це машинний варіант імені.
                В багатьох мовах програмування адреси об’єкту заховані від програміста і вважається, що вони відноситься
                до рівня машини. В мові Сі, завдячуючи операції &amp;amp; ми маємо можливість взнати і використовувати
                адресу змінної. Друк адреси змінної не є основним застосуванням операції &amp;amp;. Більш важливим є те,
                що наявність операцій &amp;amp;, * і покажчиків дозволяє обробляти адреси і їх вміст в символьному
                вигляді, що ми й зробили в програмі обмін3.
				</text>
				</sub_item>
				<sub_item>
				<item_title> 5.7. Опис типу функцій</item_title>
				<text>

                
                Тип функції визначається типом значення, яке вона повертає в функцію виклику. Якщо вказівка типу
                відсутня, тоді по замовчуванню вважається, що функція має тип int. Якщо значення функції не належить
                типу int, тоді потрібно вказати її тип в двох місцях.
                1. Описати тип функції в її визначенні:
                char pun(ch,n) /* функція повертає символ */
                int n;
                char ch;
                float raft(num) /* функція повертає величину типу float */
                int num;
                2. Описати тип функції і в функції-виклику. Опис функції повинен знаходитись поряд з описом змінних, але
                наявність дужок буде вказувати, що даний об’єкт опису буде функцією:

                main()
                {
                char c, pun();
                float raft;
                . . .
				</text>
				</sub_item>
				<sub_item>
				<item_title> 5.8. Тип параметру - функція</item_title>
				<text>
                
                Звернення до параметру-функції має вигляд:
                (* ім’я) (список аргументів для функції аргументу).
                При виконанні функції, що містить таке звертання, значенням покажчика-параметра є адреса функції,
                заданої аргументом; воно приводить до виклику функції аргументу.
                Розглянемо таку задачу [5]. Нехай f1(x) і f2(x) задають обчислення монотонних функцій f1 і f2, кожна з
                яких має корінь на проміжку (a,b) крім того fi(a) &amp;amp;lt; 0 &amp;amp;lt; fi(b), i=1,2. Обчислити
                корені з точністю до  як елементи послідовності xm заданої рекурентними співвідношеннями:
                x1=(a+b)/2, xi=xi-1-sign(fі(xi-1))*(b-a)/2 і,
                де m найменше з чисел, для яких (b-a)/2 m&amp;amp;lt;.
                Наведемо програму, яка реалізує цей алгоритм:
                #include &amp;amp;lt;stdio. h&amp;amp;gt;
                double f1(x)
                double x;
                { /* тіло функції f1(x) */
                . . .
                }
                double f2(x)
                double x;
                { /* тіло функції f2(x) */
                . . .
                }


                main()
                { double a,b,eps,x,sign(),d;
                int n;
                scanf(“%f %f %f”,&amp;amp;a, &amp;amp;b, &amp;amp;eps);
                for (n=1;n&amp;amp;lt;=2;n++)
                { for (x=(b-a)/2, d=x/2; d&amp;amp;gt;eps; d/=2)
                x=(n-2)? sign(f1,x):sign(f2,x))*d;
                printf(“f%1d(%g)=0 з точністю %g”,n,x,eps);
                }
                }
                double sign(f,x)
                double (*f)(), x;
                { return ((*f)(x) &amp;amp;gt; 0 ? 1 : ((*f)(x) ? -1 : 0));}
                Вона читає значення a,b, обчислює та друкує корені функцій f1, f2; імена функцій f1 і f2 передаються
                аргументам функції sign(), яка обчислює знак значення свого параметру функції у точці x. Для n=1
                обчислюється корінь функції f1, а для n=2 - корінь f2.
				</text>
				</sub_item>
				<sub_item>
				<item_title> 5.9. Рівноправність функцій</item_title>
				<text>
                
                Всі функції в мові Сі рівноправні. Кожна з них може викликати любу іншу функцію. Це робить функції Сі
                відмінними від процедур Паскалю. Оскільки процедури Паскалю можуть бути вкладені в інші процедури (до
                того ж, процедури, які містяться в одному гнізді, є недоступними для процедур, які знаходяться в іншому
                гнізді).
                Свою специфіку має тільки функція main(). Вона заключається в конструюванні програми, яка складається з
                декількох функцій, в початку виконання програми з першого оператору main(). Але цим її особливість і
                закінчується. Функція main() може бути викликана іншими функціями:
                /* виклик функції main() */
                #include &amp;amp;lt;stdio.h&amp;amp;gt;
                main()
                { char ch;
                printf (“Вкажіть довільний символ. Q-ознака кінця роботи.\n”);
                ch=getchar();
                printf (“Так! Ви вказали %c!\n”,ch);
                if (ch !=Q) more ();
                }

                more();
                {
                main();
                }
                В цьому випадку main() викликає more(), а функція more() викликає main() і її виконання починається
                спочатку. Ми організували неявний цикл.
                Функція може також викликати себе рекурсивно:
                /* main.main */
                #include&amp;amp;lt;stdio.h&amp;amp;gt;
                main()
                { char ch;
                printf ( --------------- );
                ch=getchar();
                printf ( ---------------- );
                if (ch !=Q)
                main();
                }
                Коли функція main() викликає сама себе, не проходить передачі керування на її початок. Замість цього в
                пам’яті машини створюються копії всього набору змінних функції main() з повними адресами.
				</text>
				</sub_item>
				<sub_item>
				<item_title> 5.10. Компіляція програм, які складаються із двох і більше функцій</item_title>
				<text>
                
                Найпростіший спосіб компіляції і використання декількох функцій в одній програмі полягає в тому, щоб
                помістити їх в один файл. Після можна компілювати цю програму так, ніби вона складається з одної
                функції.
                Другий спосіб полягає в використанні директиви #include. Якщо одна функція знаходиться в одному файлі, а
                інша в другому файлі, тоді в одному з файлів повинна бути добавлена директива
                #include “ім’я іншого файлу”.
				</text>
				</sub_item>
				<sub_item>
				<item_title>  5.11. Функція отримання цілих чисел</item_title>
				<text>
               
                Відмінність нашої майбутньої функції від стандартної функції scanf( ) в більш потужнішій перевірці на
                правильність введення цілого числа.
                Будемо притримуватись такої стратегії. Інформацію введення можна читати як стрічкусимволів. Тому будемо
                притримуватись алгоритму:
                1. Прочитати інформацію вводу як символьну стрічку.
                2. Перевіримо, складається наша стрічка тільки із символів та цифр і наявність знаку перед нею.
                3. Якщо це так, тоді перетворимо символьну стрічку в правильне числове значення.
                4. Якщо ні, тоді надрукуємо повідомлення.
                Зараз розглянемо інтерфейс нашої функції getint( ) з довкіллям.
				</text>
				</sub_item>
				<sub_item>
				<item_title>  5.11.1. Потік інформації для getint()</item_title>
				<text>
                
                Який вихід повинна мати наша функція? Вона повинна повертати два значення: ціле число і стан. Тому
                використовувати функцію return() тут не можливо. Потрібно мати два покажчики. Але повне вирішення задачі
                ми отримаємо, якщо використаємо покажчики для виконання основної роботи функції і функцію return для
                видачі деякого стану. Якраз це і робить функція scanf(). Вона повертає кількість символів, які знайшла і
                символ EOF, якщо знайшла його. Раніше ми не використовували такої можливості, але могли б, якщо б
                застосували виклик такого типу :
                status = scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp; number);
                Зараз ми будемо це робити. Тоді наш виклик мав би вигляд:
                status = getint(&amp;amp; number);
                Права частина рівності використовує адресу змінної number щоб отримати її значення, а return
                використовується для отримання значення змінної status. Цей процес ілюструє малюнок 5.2.

                Ввід. Вивід.
                Адреса змінної Значення змінної
                типу int . типу int .
                Повернення(внутрішній стан)
                Мал.5.2. Створення функції getint( ).

                Закодуємо типи повідомлень про стан. Оскільки неописані функції мають тип int , наше кодування повинно
                використовувати цілі числа:
                -1 означає, що знайшли символ EOF;
                1 означає, що знайдена стрічка, яка має символи відмінні від цифр;
                0 означає, що знайдена стрічка, яка складається тільки з цифр;
                Враховуючи мал.5.2, скелет нашої функції повинен бути таким :
                getint(ptint)
                int *ptint; /*покажчик на ціле число */
                { int status;
                . . .
                return(status);
                }.
                Заповнимо тіло функції getint(). Воно повинно реалізовувати такі дії:
                - читати на вході інформацію у вигляді символів;
                - розміщувати символи в стрічку доки не зустрінемо EOF;
                - якщо зустрівся символ EOF, встановимо сталі в STOP (1)
                інакше: перевіряємо стрічку, перетворюємо символи в ціле число, якщо можливо і видаємо повідомлення про
                стан (YESNUM(0) або NONUM(1).
                Розглянемо ще деякі питання. Як функція буде вирішувати, коли вона досягнула кінця стрічки вводу? Чи
                повинні ми обмежувати довжину стрічки?
                Будемо вважати, що функція повинна аналізувати ситуацію: стрічка повинна починатись із символу
                відмінного від проміжку або &amp;amp;quot;нової стрічки&amp;amp;quot;, і закінчується одним із цих
                символів. Таке введення дозволяє вводити інформацію із декількох стрічок.
                Обмежимо стрічку вводу 80 символами. Враховуючи закінчення стрічки нуль-символом нам буде потрібен масив
                із 81 елементів. Це досить щедро, тому що 6 символів нам потрібно для задання 16-ти розрядного цілого.
                Ми можемо вводити і більш довгі числа, але їх розмір буде скорочений до розміру стрічки. Для надання
                програмі властивостей модульності будемо використовувати функцію stoi(), для перевірки стрічка-ціле.
                Функція getint( )прийме вигляд:
                /*getint( )*/
                #include &amp;amp;lt;studio.h&amp;amp;gt;
                #define LEN 81 /* максимальна довжина стрічки */
                #define STOP-1 /* коди станів */
                #define NONUM 1
                #define YESNUM 0
                getint (ptint)
                int *ptint;
                { char intarr[LEN];
                int ch;
                int ind=0; /* індекс масиву */
                while ((ch=getchar()) == &amp;amp;apos;\n&amp;amp;apos; |ch==&amp;amp;apos;&amp;amp;apos; || ch==&amp;amp;apos;\t&amp;amp;apos;);
                /* обхід початкових проміжків і знаків нової стрічки і
                табуляції */
                while(ch!=EOF &amp;amp;&amp;amp; ch!=&amp;amp;apos;\n&amp;amp;apos; &amp;amp;&amp;amp; ch!=&amp;amp;apos;&amp;amp;apos;
                &amp;amp;&amp;amp; ind&amp;amp;lt;LEM)
                {intarr[ind++]=ch; /* запис символу в масив */
                ch=getchar() /* отримання чергового символу */ }
                intarr[ind]=&amp;amp;apos;\0&amp;amp;apos;; /* кінець масиву */
                if(ch==EOF)
                return(STOP);
                else
                return(stoi(intarr,ptint)); /* виконання перетворення */
                }
                Що робить функція stoi()? При введенні вона бере символьну стрічку і покажчик на цілу змінну,
                використовує покажчик для присвоєння самої змінної, а також return для передачі повідомлення про стан.
                Можна запропонувати більш компактніший спосіб використання функції stoi(): status = stoi(intarr,print);
                return(status). Тут status була змінною типу int. Перший оператор дає значення, на яке вказує ptint;
                присвоюється значення змінній status. Другий оператор повертає це значення програмі, яка викликала
                getint().
				</text>
				</sub_item>
				<sub_item>
				<item_title>   5.11.2. Функція stoi()</item_title>
				<text>
               
                Скелет нашої функції буде мати приблизно такий вигляд :

                stoi(string, intptr)
                char string [ ]; /* стрічка вводу */
                int *intptr /* покажчик на змінну, яка отримує ціле значення */
                { int sign=1; /* перевіряє наявність знаку +,- */
                int index=0;
                if( string[index]==&amp;amp;apos;-&amp;amp;apos; || string[index]==&amp;amp;apos;+&amp;amp;apos; )
                sign=string[index++]==&amp;amp;apos;-&amp;amp;apos;) ? -1 : 1; /* встановити знак */
                *intptr=0; /* початкове значення */
                while( string [index] &amp;amp;gt;= &amp;amp;apos;\0&amp;amp;apos; &amp;amp;&amp;amp; string [index]
                &amp;amp;lt;= &amp;amp;apos;9&amp;amp;apos; )
                *intptr = 10* (*intptr) + ( string[index++] &amp;amp;apos;&amp;amp;apos; );
                if (string[idex] == &amp;amp;apos;&amp;amp;apos;)
                {*intptr=sign*(*intptr);
                return (YESNUM);
                }
                else/* знайдемо символ, відмінний від цифри, знаку, нуль-символу */
                return(NONUM);
                }
                Функцію будемо зберігати в тому ж файлі, що і getint(), тому ми можемо використовувати одні директиви
                define.
                Для переводу символу &amp;amp;apos;&amp;amp;&amp;amp;apos; в число використовується той факт, що всі
                символи впорядковані в коді ASCII. Тому, якщо від &amp;amp;apos;символа-цифри&amp;amp;apos; відняти
                &amp;amp;apos;0&amp;amp;apos;, то отримуємо числове значення відповідної цифри.
                Для перевірки роботи наших функцій скористаємось програмою:
                #define STOP -1
                #define NONUM 1
                #define YESNUM 
                main()
                { int num, status;
                printf (&amp;amp;quot;Програма закінчує читання чисел при
                зустрічі з EOF. \n&amp;amp;quot;);
                while ( status=getint(&amp;amp;num)) != STOP)
                if ( status==YESNUM)
                printf(&amp;amp;quot;Число %d сприйнято.\n&amp;amp;quot;, num);
                else
                printf(&amp;amp;quot;Це не ціле число! Спробуйте знов.\n&amp;amp;quot;);
                printf (&amp;amp;quot;Це не воно.\n&amp;amp;quot;);
                }
                Зазначимо, що перед знаком EOF потрібно після числа ввести один проміжок.
                Стандартна бібліотека Сі містить функцію atoi() переводу коду ASCII в ціле число.Вона схожа на stoi()
                перевіряє нецифрові стрічки, а atoi() використовує return замість покажчика, для повернення числа і
                пропускає проміжок, як ми робили в getint().
				</text>
				</sub_item>
				</sub_item>
                Вправи і завдання до розділу 5:
                5.1. Hаписати функцію detab, яка замiнює символи табуляцїї на пpопуски (вiдповiдну кiлькiсть).
                5.2. Hаписати функцiю entab, яка замiнює пpопуски у вхiдному потоцi на символи табуляцiї.
                5.3.Hаписати функцiю htoi(s), яка пеpетвоpює 16-кову стpiчку в 10-кове число.
                5.4. Hаписати функцію strcat(s,t), яка пpиєднує стpiчку t до s.
                5.5. Hаписати функцiю any(s1,s2), яка дає пеpше мiсцезнаходження в стpiчцi s1 cимволiв iз s2. Якщо немає
                жодного входження, функцiя повеpтає -1.
                5.6. Розглянемо функцiю getbits(x,p,n), яка дає n-pозpядне поле (виpiвняне зпpава) iз x , яке
                починається з позицiї p. Вважаємо, що нульовий pозpяд - самий пpавий pозpяд а n i p додатнi величини.
                Напишіть таку функцію.
                а)модифiкуйте getbits, вважаючи що pозpяди нумеpуються злiва-напpаво;
                б)написати функцiю wordlength(), яка виpаховує pозмip слова вашого комп&amp;amp;apos;ютеpа (число
                pозpядiв в int);
                в)написати функцiю rightron(n,b), яка &amp;amp;quot; обеpтає &amp;amp;quot; цiле число n впpаво на b
                pозpядiв;
                г)написати функцiю invert(x,p,n), яка iнвеpтує (замiнює 1 на 0 i навпаки) n pозpядiв iз x, починаючи iз
                p-тої позицiї.
                5.7.* Обчислити функцію f(x) = [sqrt(x)] (ціла частина від квадратного кореня). Використовувати змінні
                типу real забороняється.
                5.8.* Функція f задана наступним чином: f(x) = x/2 якщо x парне, f(x) = 3*x + 1 якщо x непарне. Для
                заданого натурального n побудуємо послідовність n1, n2, ..., nk , в якій n = n1, ni+1 = f(ni), 1&amp;amp;lt;i&amp;amp;lt;k,
                nk=1, nk-11. Довжину цієї послідовності назвемо циклом числа n. Для заданих натуральних a та b, a&amp;amp;lt;b&amp;amp;lt;10000
                знайти число k з проміжку [a, b] з максимальним циклом. Надрукувати число k та довжину його циклу.

			
            </sub_item>
			
				<sub_item>
				<item_title>   6. Класи пам&amp;amp;apos;яті</item_title>
				<text>
            
            Одна із переваг мови Сі полягає в тому, що вона дозволяє керувати такими механізмами програми як класи пам&amp;amp;apos;яті.
            Важливою ланкою програми є оператор-описувач змінних. Тип описувача визначає ім&amp;amp;apos;я і тип
            змінної, а місце розміщення описувача з відповідним службовим словом (специфікатором класу пам&amp;amp;apos;яті)--клас
            пам&amp;amp;apos;яті. Один з них може бути відсутнім, але не обидва разом. Відсутній специфікатор типу за
            узгодженням є типом int . Для опису класу пам&amp;amp;apos;яті використовуються службові слова:
            extern(зовнішня), static(статична), auto(тимчасова) і register(регістрова).
            Всі імена можуть бути внутрішніми (локальними) або зовнішніми. Зовнішніми іменами називаються імена функцій
            або імена описані ззовні блоку чи імена описані в середині блоку з специфікатором extern. Решта імен
            називаються внутрішніми.
            Основними типами пам&amp;amp;apos;яті є постійна (статична) та тимчасова (автоматична). Постійна пам&amp;amp;apos;ять
            виділяється на початку виконання програми і звільнюється при її завершенні. В постійній пам&amp;amp;apos;яті
            розміщуються зовнішні змінні і внутрішні змінні, описані з специфікатором static. Усі інші змінні
            розміщуються у тимчасовій пам&amp;amp;apos;яті. На початку дії блоку, пам&amp;amp;apos;ять виділяється для
            внутрішніх змінних цього блоку, а при завершенні роботи - вона звільнюється. Параметри функції також
            належать до внутрішніх змінних.
            Внутрішні змінні, описані без специфікатору класу пам&amp;amp;apos;яті, належать до класу auto, а змінні
            описані з специфікатором register належать до класу регістрової пам&amp;amp;apos;яті. Регістрові змінні
            розміщуються в спеціальних регістрах обчислювального пристрою. Традиційно, для більшості ЕОМ, кількість
            регістрів значно обмежена, в порівнянні з іншими типами пам&amp;amp;apos;яті. Тому в деяких реалізаціях, в
            них, можуть бути розміщені тільки цілі і покажчики, і при неможливості задоволення потреби в регістровій пам&amp;amp;apos;яті,
            компілятор сам переводить їх в клас тимчасової пам&amp;amp;apos;яті auto . Параметри функції належать класу
            auto або register. Мабуть зрозуміло, що до змінних типу register не можна застосовувати операцію взяття
            адреси &amp;amp;.
            Зовнішня змінна описана з специфікатором static доступна в усіх функціях файлу з цим зовнішнім описом, але
            не доступна в інших файлах. Внутрішня змінна описана з специфікатором static доступна тільки в цьому блоці,
            але її значення зберігається між повторними виконаннями блоку функції. Інші змінні доступні в блоках їх
            опису. З області дії всіх описів вилучаються блоки з локальними переозначеннями відповідних змінних.
            Отже, клас пам&amp;amp;apos;яті змінної визначає два факти: дозволяє встановлювати які з функцій мають
            доступ до змінної, і як довго змінні знаходяться в пам&amp;amp;apos;яті.
            Розглянемо властивості кожного типу пам&amp;amp;apos;яті.
			</text>
			
				<sub_item>
				<item_title>   6.1. Автоматичні зміннні</item_title>
				<text>
            
            Змінні описані в середині функції є автоматичними. Цей факт також можна вказати, використавши явно
            специфікатор auto:
            main()
            {auto int x ;
            . . .
            Наявність специфікатора auto наголошує про те, що опис змінної не потрібно шукати поза межами функції.
            Автоматичні змінні мають локальну область дії: починають існувати при виклику функції, яка містить їх. При
            поверненні керування в функцію виклику, комірки пам&amp;amp;apos;яті відведені під автоматичні змінні
            функції, яка викликалась, звільнюються і можуть використовуватись для чогось іншого.
            Область дії автоматичної змінної обмежена блоком ({. . .}), в якому змінна описана.
			</text>
            </sub_item>
			
				<sub_item>
				<item_title>  6.2. Зовнішні змінні</item_title>
				<text>
            
            
            Змінна, яка описана зовні функції називається зовнішньою. Зовнішню змінну можна також описати в функції, яка
            використовує її, за допомогою специфікатора extern. Наприклад:
            int x; \*три змінні описані зовні функції *\
            char y;
            char z;
            main()
            {extern int x ;
            extern char y ;
            extern char z ;
            . . .
            Групу extern описів можна не використовувати, якщо початкові визначення змінних з&amp;amp;apos;являються в
            цьому ж файлі і перед функцією, яка їх використовує. Використання слова extern дозволяє функції
            використовувати зовнішню змінну, навіть тоді, коли вона визначається пізніше в тому ж або іншому файлі. В
            останньому випадку, файли повинні бути компільовані, зв&amp;amp;apos;язані та зібрані в один і той же час.
            Якщо слово extern не включено в опис в середині функції, тоді під цим ім&amp;amp;apos;ям створюється нова
            автоматична змінна. Якщо ви тут ставите описувач auto , то цим ви наголошуєте, що це ваш намір а не помилка.
            Три приклади демонструють чотири можливі комбінації описів:
            /*приклад 1*/
            int x;
            main()
            { extern int x;
            . . .
            }
            magic ( )
            { extern int x;
            . . .
            }
            В цьому випадку одна зовнішня змінна х доступна функціям main() i magic().

            /*приклад 2*/
            int x;
            main()
            {
            extern x;
            . . .
            main()
            { . . . /* x не описана зовсім */
            }
            Знову зовнішня змінна х доступна і функції main() і функції magic(). Останній вона доступна по замовчуванню.

            /*приклад 3*/
            int x;
            main()
            { int x;
            . . .
            }
            magic()
            { auto int x ;
            . . .
            }
            В цьому прикладі створено три різні змінні з однаковим ім&amp;amp;apos;ям. Зовнішня змінна х не відома ні
            main() ні magic(), але відома іншій функції із цього файлу, яка не містить в свому тілі опису змінної х без
            специфікатору extern. Змінна х в функції main() є тимчасовою по замовчуванню і локальною для main() .
            Змінна х із функції magic() є локальною для magic() і описана явно як тимчасова.
			</text>
            </sub_item>
			
				<sub_item>
				<item_title>  6.3. Статичні змінні</item_title>
				<text>
            
            Статичні змінні мають таку ж область дії як і автоматичні змінні. Але після завершення роботи функції, яка
            їх містить, вони не пропадають. Компілятор зберігає їх значення від одного виклику функції до іншого.
            Pозглянемо приклад:

            main()
            { int count ;
            for ( count =1; count &amp;amp;lt;=3; count ++)
            { printf (&amp;amp;quot;Ітерація %d:\n&amp;amp;quot; , count );
            trystat();
            }
            }
            trystat()
            { int fade=1
            static int stay=1,
            printf (&amp;amp;apos;fade =%D i stay=%d\u&amp;amp;apos;, fade++, stay++);
            }
            Робота цієї програми дасть наступні результати :
            Ітерація 1:
            fade=1 i stay =1
            Ітерація 2:
            fade=1 i stay =2
            Ітерація 3:
            fade=1 i stay =3
            Статична змінна stay пам&amp;amp;apos;ятає , що її значення було збільшено на 1, на противагу, для змінної
            fade початкове значення встановлюється кожний раз знову.
			</text>
            </sub_item>
			
				<sub_item>
				<item_title>  6.4. Зовнішні статичні змінні</item_title>
				<text>
            
            Ми можемо описати і зовнішню змінну з специфікатором static. Різниця між зовнішньою змінною і зовнішньою
            статичною змінною проявляється в області їх дії. Традиційна зовнішня змінна може використовуватись функціями
            в любому файлі, а зовнішня статична змінна може використовуватись тільки функціями того ж файлу, де вона
            визначена; крім того, після визначення змінної. Ви можете розмістити зовнішню статичну змінну, розміщуючи її
            визначення ззовні любої функції:
            static rand x=1;
            rand ( )
            {. . .
            }
            Відмінність опису зовнішніх і зовнішніх статичних змінних демонструє малюнок 6.1.

            Файл1 і Файл2 відкомпільовані разом.

            _____________________/\_____________________
            / файл1 файл2 \


            Мал. 6.1. Зовнішні і зовнішні статичні змінні.

            twit доступна функціям main(), figaro(), hedge(), mostly(), а змінна tum доступна тільки функціям main() i
            figaro().
			</text>
            </sub_item>
			
				<sub_item>
				<item_title>  6.5. Регістрові змінні</item_title>
				<text>
            
            Іноді потрібно мати швидкий доступ до змінних. Традиційно змінні зберігаються в пам&amp;amp;apos;яті ЕОМ.
            Але їх також можна зберігати в регістрах центрального процесора, де доступ і робота проводиться значно
            швидше. В усьому іншому регістрові змінні аналогічні автоматичним змінним. Вони створюються наступним чином
            :
            main()
            {
            register int guid;
            . . .
            Тому, що кількість регістрів обмежена, наше прохання може бути не задоволене компілятором. В цьому випадку
            змінна становиться тимчасовою.
			</text>
            </sub_item>
			
				<sub_item>
				<item_title>   6.6. Якому класу пам&amp;amp;apos;яті віддати перевагу?</item_title>
				<text>
           
            Відповідь на це питання завжди однозначна &amp;amp;quot;тимчасову&amp;amp;quot;. Мабуть тому цей клас пам&amp;amp;apos;яті
            використовується і по замовчуванні. Зрозуміло, що використавши зовнішні змінні ми могли б обійтись і без
            використання аргументів функцій і покажчиків. Але їх використання пов&amp;amp;apos;язане з різними
            необхідними ефектами. Тому одне із золотих правил програмування заключається в дотримуванні принципу &amp;amp;quot;необхідно
            знати те, що потрібно&amp;amp;quot;. Іншими словами потрібно організувати роботу кожної функції автоматично,
            наскільки це можливо, і використовувати глобальні змінні тільки тоді, коли це дійсно необхідно.
            Наприклад, розглянемо функцію в якій бажано використання зовнішньої статичної змінної. Вона описує &amp;amp;quot;генератор&amp;amp;quot;
            псевдовипадкових чисел. Псевдовипадковість означає, що фактична послідовність чисел передбачувана, але вони
            розкидані досить рівномірно в межах можливого діапазону значень.
            Схема починає роботу з числа, яке назвемо базисом. Потім ітераційно вона використовує старий базис для
            створення нового числа, яке в свою чергу становиться базисом і т.д. Щоб ця схема працювала, функція
            випадкових чисел повинна пам&amp;amp;apos;ятати базис, який вона використовувала при останньому виклику.
            Отже, вона потребує статичну змінну.

            /* версія1функції rand ( ) */
            rand ( )
            { static int randx = 1;
            randx = (randx*25173+13849)%65536;
            /* магічна формула */
            return (randx);
            }
            Статична змінна randx ініціюється значенням 1 і змінюється за допомогою магічної формули кожний раз при
            виклику функції. Результатом в нашій системі є число, яке знаходиться в діапазоні від 32768 до 32767.
            Системи з різною довжиною змінної типу int будуть давати різні результати.
            Перевіримо роботу функції:
            main()
            { int count ;
            for ( count=1; count &amp;amp;lt;=S; count ++)
            printf (&amp;amp;quot;%d&amp;amp;quot;, rand( ));
            }
            Отримаємо результат:
            -26514 -4449 20196 - 20531 3882
            Ця послідовність чисел має вигляд випадкової. Запустимо нашу програму знову. Отримуємо:
            -26514 -4449 20196 -20531 38882
            абсолютно ідентичну послідовність. Це і є &amp;amp;quot;псевдоефект&amp;amp;quot;. Кожний раз, коли працює
            основна програма, ми починаємо з одного і того ж значення базису, рівного 1. Можна обійти цю проблему шляхом
            введення другої функції srandx(), яка дозволяє знову встановлювати базис в початковий стан. Хитрість
            заключається в тому, щоб зробити randx зовнішньою статичною змінною, відомою тільки функціям rand() i
            srand(). Збережемо ці дві функції в окремому файлі і компілюємо цей файл окремо. Ось модифікація нашої
            програми:
            /*файл для rand i srand ( ) */
            static int randх=1;
            rand()
            { randx = (randx *25173+13849)%65536;
            return ( randx);
            }
            srand (x);
            unsigned x;
            {
            randx=x;
            }
            Використаємо програму:
            main()
            int count;
            int seed;
            printf (&amp;amp;quot;Введіть ваше значення базису. \n&amp;amp;quot;);
            scanf (&amp;amp;quot;%d&amp;amp;quot;,&amp;amp; seed );
            srand (seed) /* встановити базис в початку змінної */
            for (count =1; count&amp;amp;lt;=5; count++)
            printf (&amp;amp;quot;%d\n,rand ( ) );
            }
            Запустимо її на виконання :
            Введіть значення базису.
            1
            -26541
            -4449
            20196
            -20531
            3882
            Використовуючи значення 1 для змінної seed, отримуємо попередню послідовність. Попробуємо ввести значення 2:
            Введіть значення базису:
            -2
            23832
            20241
            -1858
            -30417
            -16204
            На кінець маємо те що хотіли.

			</text>
            </sub_item>
			
				<sub_item>
				<item_title>   6.7. Гра в кості</item_title>
				<text>
            
            Промоделюємо на комп&amp;amp;apos;ютері гру в кості. В найбільш використовуваній формі вживаються дві фішки,
            які мають по шість сторін(два куби). Але є й інші варіанти. Багато гравців використовують любі із п&amp;amp;apos;яти
            можливих геометричних фішок, які мають 4, 6, 8, 12 і 20 сторін. Більше не можливо використовувати фішки, бо
            було доведено, що є тільки п&amp;amp;apos;ять правильних геометричних фігур з гранями однієї форми і
            розміру. Фігури з різними гранями не будуть мати рівні шанси при викиданні.
            Але на машинні обчислення ці геометричні роздуми не накладають обмежень, тому ми запропонуємо електронну
            гральну фішку, у якої по вашому бажанню може бути любе число сторін. Почнемо з 6 сторін, а потім зробимо
            узагальнення.
            Нам потрібні випадкові числа від 1 до 6, а функція rand() створює цілі числа із діапазону задання цілих
            чисел. Тому ми повинні зробити деякі правки. Ось один із варіантів.
            1. Поділимо випадкове число на 32768. Отримаємо число х,
            -1=&amp;amp;lt;x&amp;amp;lt;1. (Ми повинні перетворити його в float, щоб мати десяткові дроби ).
            2. Додамо 1. Наше нове число 0&amp;amp;lt;=x&amp;amp;lt;2.
            3. Поділимо на 2. Будемо мати 0&amp;amp;lt;=x&amp;amp;lt;1.
            4. Помножимо на 6. Маємо 0&amp;amp;lt;=x&amp;amp;lt;6.
            5. Додамо 1: 1=&amp;amp;lt;x&amp;amp;lt;7. (Відмітимо, що числа ще є десятковими дробами).
            6. Перетворимо в цілі числа і будемо мати цілі із діапазону від 1 до
            7. Для узагальнення достатньо замінити значення 6 в п. 4 на число сторін.
            Реалізуємо наш алгоритм:
            /* електронні кості */
            #define SCALE 32768.0
            rollem (sides);
            float (sides);
            { float roll;
            roll=((float)rand( )/SCALE +1.0)*sides/2.0+1.0;
            return ( (int )roll);
            }
            Побудуємо програму яка буде описувати загальний процес гри :
            /* викидання &amp;amp;quot;кості&amp;amp;quot; багато разів */
            main()
            { int dice, count, roll, seed;
            float sides;
            printf (&amp;amp;quot;Введіть значення базису . \n);
            scanf (&amp;amp;quot;%d&amp;amp;quot;, &amp;amp; seed);
            srand (seed);
            printf (&amp;amp;quot;Введіть число сторін кості і  для закінчення . \n&amp;amp;quot;);
            scanf (&amp;amp;quot;%d&amp;amp;quot;, &amp;amp; sides );
            while (sides &amp;amp;gt;0)
            { printf (&amp;amp;quot;Скільки костей?\n&amp;amp;quot;);
            scanf (&amp;amp;quot;%d&amp;amp;quot;, &amp;amp; side );
            for ( roll=0, count=1; count&amp;amp;lt;=dice;count++)
            roll+=rollem(sides); /* викидання всіх костей набору */
            printf(&amp;amp;quot;У вас випало %d,для%d %.of-сторонніх костей. \n&amp;amp;quot;,roll, dice,sides);
            printf (&amp;amp;quot;Скільки сторін? Введіть 0 для завершення . \n&amp;amp;quot;);
            scanf (&amp;amp;quot;%f&amp;amp;quot;, &amp;amp;sides);
            }
            printf(&amp;amp;quot;Успіху вам!\n&amp;amp;quot;);
            }
            Перевіримо роботу нашої програми:
            Введіть значення базису .
            1
            Введіть число сторін кості і 0 для закінчення .
            6
            Скільки костей?
            2
            У вас випало 4 для 2 6-сторонніх костей.
            Скільки сторін ?Введіть 0 для закінчення.
            0
            Успіху вам!
			</text>
            </sub_item>
			

            Вправи і завдання до розділу 6:
            6.1. Написати програму роботи простого калькулятора, що допускає тільки цілі числа і операції над ними: +,
            -, *, / ,=. Для запису виразів обчислення калькуляторів використовувати зворотній польський запис.
            6.2. Написати рекурсивну функцію, яка друкує числа, як послідовності символів і навпаки .
            6.3. Написати функцію піднесення до степеню з двома аргументами: число, яке підноситься, і сам показник,
            який може бути і від’ємним.
            6.4. Написати довільні дві функції, які взаємодіють між собою. Записати їх в окремі файли, роздільно
            відкомпілювати і організувати їх виконання.
            6.5. Скласти програму, яка читає натуральні числа m, n і друкує всі натуральні числа, використовуючи
            функцію, менші від n, сума цифр яких дорівнюють m.
            6.6. Записати функцію, яка за аргументом u , для u&amp;amp;gt;0 повертає u-те просте число, а для u&amp;amp;lt;=0
            повертає число, рівне кількості звернень до цієї функції.
            6.7. Написати функцію get_float, яка виділяє з вхідного потоку символів дійсне число, записане в одному із
            допустимих форматів, та перетворює цю послідовність в значення типу float.
            6.8.* Натуральне число N&amp;amp;gt;1 представити у вигляді суми натуральних чисел так, щоб добуток цих
            доданків був максимальний.
            6.9.* Задається додатнє дійсне число R. Знайти додатні дійсні R1, R2, ..., Rn, Ri&amp;amp;lt;4, i=1,...,n,
            такі, що R=R1*R2*...*Rn=R1+R2+...+Rn
            6.10.* Дано цілі числа А(0),А(1),...,А(5). Знайти всі корні рівняння А(5)*X5 + А(4)*X4 + ... + А(0) = 0
        </sub_item>
			
				<sub_item>
				<item_title>  7. Покажчики</item_title>
				<text>
            
            Покажчик є змінною, значенням якої буде адреса другої змінної. Покажчики в Сі використовуються для більш
            ефективної роботи з пам’яттю. При відповідній дисципліні програмування за допомогою використання покажчиків
            можна покращити структуру програми, додати якості і простоти програмі.

            Через покажчик можливе “побічне” звернення до об’єкту. Нехай, x- змінна типу int, а px - деякий покажчик ,
            невідомо як створений. Ми вже знайомились з операцією &amp;amp;, яка дає адресу об’єкту, тому оператор px=&amp;amp;x
            присвоює покажчику px адресу змінної x і кажуть, що px “вказує” на x. Операцію взяття адреси можна
            застосовувати тільки до змінних і елементів масивів.
			 </text>
			 
				<sub_item>
				<item_title>  7.1. Покажчики і адреси</item_title>
				<text>
            
            Унарна операція * трактує свій операнд, як адресу деякого об’єкту і використовує цю адресу для отримання
            вмісту вказаного фрагменту пам’яті. Візьмемо змінну y цілого типу int, тоді оператор y=*px присвоює змінній
            y вміст того, на що вказує px. Тому, послідовність операторів
            px = &amp;amp;x;
            y=*px;
            семантично еквівалентна (присвоює те саме, що й)
            y = x.
            Змінні повинні були б бути попередньо описані:
            int х, y;
            int *px;
            Останній опис констатує, що змінна px є покажчиком, який завжди вказує на об’єкт визначеного типу, в даному
            випадку int.
            Покажчики можуть зустрічатись і в виразах. Наприклад, якщо px - покажчик на ціле x, тоді *px може
            зустрічатись в любому місці, де може зустрічатись змінна x. Так оператор
            y = *px + 1;
            присвоює y значення х збільшене на 1. Наголосимо тільки, що операції * і &amp;amp; мають вищий пріоритет за
            арифметичні функції. Покажчики можуть зустрічатись і в лівій частині операції присвоєння:
            *px = 0; - присвоює змінній x значення 0;
            *px += 1; - збільшує змінну x на 1;
            (*px)++ ; - збільшує змінну x на 1.
            Якщо py інший покажчик на змінну (описаний int *px), тоді оператор
            py = px;
            копіює вміст px в py, іншими словами покажчик py починає вказувати на той же об’єкт, на який вказував і
            вказує покажчик px.
			</text>
			 </sub_item>
				<sub_item>
				<item_title>  7.2. Покажчики і масиви</item_title>
				<text>
            
            В мові Сі люба дія, яка досягається індексуванням масиву, може бути реалізована і за допомогою покажчиків.
            Варіант з покажчиками буде швидший, але важчий для розуміння, якщо ви тільки почали працювати з Сі.
            Опис int a[10] визначає масив з десяти елементів. Блок із десяти послідовних об’єктів іменується як a[0],
            a[1], ..., a[9]. Запис a[i] позначає і-ий від початку елемент блоку. Якщо ми опишемо покажчик pa, як int
            *pa, тоді присвоєння: a = &amp;amp;a[0] встановлює в pa посилання на нульовий елемент a, іншими словами, pa
            містить адресу a[0]. Тому, якщо ми запишемо x = *pa то, x буде рівне значенню елементу масиву a[0].
            Якщо вміст pa вказує на окремий елемент масиву a, тоді, за визначенням, pa-i вказує на і-ий елемент перед
            pa, а pa+i - на i-ий елемент після. Отже, якщо pa вказує на а[0], тоді:
            *(pa+1) - відноситься до вмісту a[1];
            pa+i - є адресою a[i];
            *(pa+i) - вміст a[i].
            Визначення операції “додати 1 до покажчика” використовує поняття масштабування, яке пов’язане з розміром
            пам’яті для об’єкту, на який вказує покажчик. Таким чином в pa+i значення і, перед додаванням до pa, буде
            помножене на розмір об’єкту, на який вказує pa.
            Розглянемо програму:
            main()
            { int dates[4], *pti, index;
            float bills[4], *ptf;
            pti=dates;
            ptf=bills;
            for (index=; index&amp;amp;lt;4; index++)
            printf(“покажчик і +%d:%10u %10u\n”,
            index, pti+index, ptf+index);
            }
            Отримаємо результат
            покажчики +0: 56014 56026
            покажчики +1: 56016 56030
            покажчики +2: 56018 56034
            покажчики +4: 56020 56038
            Може здивувати, що 56014+1=56016? Але згадаємо маштабування. В нашій системі одиницею адресації є байт, але
            тип int використовує два байти, а тип float - 4. Ось чому ми обов’язково повинні зазначати тип об’єкту, на
            який вказує покажчик.
            Зв’язок індексування з арифметикою покажчиків в Сі такий. Фактично, любе згадування масиву переводиться
            транслятором до покажчика на початок цього масиву, інакше кажучи ім’я масиву є покажчиковим виразом. Це
            приводить до великої кількості корисних наслідків. Наприклад, присвоєння pa = &amp;amp;a[0] може бути
            записане у вигляді pa = a, а обчислюючи a[i], транслятор зразу переводить його до *(a+i). Ці форми повністю
            еквівалентні, як і наступні:
            &amp;amp;a[i] та a+i - адреса i-ого елементу відносно a;
            *(pa+i) та pa[i] - якщо pa-покажчик .
            Але між ім’ям масиву і покажчиком є одна відмінність, про яку завжди потрібно пам’ятати. Покажчик є змінна,
            тому pa = a і pa++ є осмисленими операціями. Ім’я масиву ж - константа, тому конструкції типу a = pa, a++
            або p = &amp;amp;a недопустимі.
			</text>
			 </sub_item>
				<sub_item>
				<item_title> 7.3. Функції, масиви та покажчики</item_title>
				<text>
            
            Масиви можуть бути аргументами функцій. Розглянемо масиви під цим кутом зору. Давайте проаналізуємо скелет
            програми, звертаючи увагу на оператори-описувaчі:
            /* масив-аргумент */
            main()
            int ages[50];
            convert(ages);
            . . .
            }
            convert(jears);
            int jears[ ]; /* який розмір масиву? */
            {
            . . .
            }
            В цьому випадку масив ages складається з 50 елементів. А що можна сказати про масив years? В програмі немає
            такого масиву. Описувач int years[ ] створює не масив, а покажчик на нього. Подивимось, чому це так.
            Розглянемо виклик нашої функції convert(ages)? Згадаємо, що ім’я ages є покажчиком на перший елемент масиву,
            який складається з 50 елементів. Таким чином, оператор виклику функції передає їй покажчик , інакше кажучи,
            адресу функції convert(). Це означає, що аргумент функції є покажчиком, і ми можемо написати функцію
            convert() так:
            convert(years);
            int *years;
            {
            }
            і оператори, які використовують покажчик years в функції convert(), фактично працюють з масивом ages, який
            знаходиться в тілі функції main().
			</text>
			 </sub_item>
				<sub_item>
				<item_title> 7.4. Адресна арифметика</item_title>
				<text>
            
            Мова Сі послідовна і регулярна в підході до адресної арифметики; цілісність і взаємозв’язок покажчиків,
            масивів і адресної арифметики є одним із основних переваг мови. Мова надає п’ять основних переваг, які можна
            застосувати до покажчиків.
            /* операції з покажчиками */
            #define PR(X) printf (“ X=%u, *X=%d, &amp;amp;X=%u\n”, X, *X, &amp;amp;X)
            main()
            static int urn[ ]={ 100, 200, 300 };
            int *ptr1, *ptr2;
            { ptr1=urn; /* присвоює адреси покажчику */
            ptr2=&amp;amp;urn; /* та ж дія */
            PR(ptr1); /* друк */
            ptr1++; /* збільшення покажчика */
            PR(ptr1);
            PR(ptr2);
            ++ptr2; /* виходить за кінець масиву */
            PR(ptr2);
            printf (“ptr2-ptr1=%u\n”, ptr2-ptr1);
            }
            В результаті роботи програми отримаємо такі результати:
            ptr1=18, *ptr1=100, &amp;amp;ptr1=55990
            ptr1=20, *ptr1=200, &amp;amp;ptr1=55990
            ptr2=22, *ptr2=300, &amp;amp;ptr2=55992
            ptr2=24, *ptr2=29808, &amp;amp;ptr2=55992
            ptr2-ptr1=2.

            Присвоєння. Покажчику можна присвоїти адресу. Традиційно реалізовуємо цю дію, використовуючи або ім’я
            масиву, або операцію отримання адреси(&amp;amp;). В останній програмі покажчику ptr присвоюється адреса
            початку масиву urn; ця адреса належить комірці пам’яті з номером 18 (статичні змінні в нашій системі
            запам’ятовуються в комірках оперативної пам’яті). Змінна ptr2 отримує адресу третього елементу масиву.

            Визначення. Операція * видає значення, яке зберігається в зазначеній комірці. Якщо в 18-ій комірці
            зберігається число 100, тоді *ptr1==100.

            Отримання адреси покажчика. Як і інші змінні, покажчик має адресу і значення. Операція &amp;amp; повідомляє,
            де знаходиться покажчик. В нашому прикладі покажчик ptr1 знаходиться в комірці з номером 55990. Ця комірка
            містить число 18, яке є адресою початку масиву urn.

            Збільшення покажчика. Ми можемо зробити цю дію за допомогою звичайної операції додавання або за допомогою
            операції збільшення. Збільшуючи покажчик, ми переміщуємо його на наступний елемент масиву. Тому операція
            ptr1++ збільшує числове значення змінної ptr1 на 2 (два байти займає кожний елемент масиву) і покажчик ptr1
            буде посилатись уже на urn[1]. Зараз ptr1 має адресу наступного елементу масиву 20, а операція *ptr1 видає
            число 200. Відмітимо, що адреса самої комірки ptr1 залишається незмінною (55990). Після виконання операції
            сама змінна не перемістилась, тому що вона змінила значення.
            Аналогічно можна і зменшувати покажчик .
            При виконанні цих операцій потрібно бути обережним. Машина не враховує чи ще покажчик посилається на елемент
            масиву, чи вже вийшов за його межі. Останній приріст ptr2 характеризує таку ситуацію.
            До того ж, оператор збільшення можна використовувати тільки до змінної типу покажчик, але не до константи
            цього типу:
            Правильно Неправильно
            ptr1++ urn++
            x++ 3++
            ptr2=ptr1+2; ptr2=urn++
            ptr2=urn+1; x=y+3^++

            Різниця. Можна знаходити різницю двох покажчиків. Традиційно не застосовується до покажчиків, які
            посилаються на елементи одного й того ж масиву, щоб з’ясувати, на якій віддалі знаходяться відповідні
            елементи масиву.
            Програмісти створюють в мові Сі програми, які містять масиви покажчиків, покажчики на функцію, масиви
            покажчиків на покажчики, масиви покажчиків на функції і т.д.
			</text>
			 </sub_item>
				<sub_item>
				<item_title>  7.5. Просте використання покажчиків</item_title>
				<text>
           
            Розглянемо приклад “рудиментарного” розподілювача пам’яті. Він може стати корисним за рахунок своєї
            простоти. Є дві функції alloc(n) і free(p). Перша видає покажчик p, який вказує на n послідовних
            “символьних” позицій. В цих позиціях можна зберігати потрібну інформацію. Функції free і alloc працюють з
            зовнішнім масивом символів allocbuf. Він повинен бути локальним в файлі, який містить функції alloc і free.
            В практичній реалізації це може бути і неіменований масив. Це ім’я можна отримувати від операційної системи,
            як покажчик на деякий безіменний блок пам’яті.
            Потрібна також інформація, яка характеризувала б, вільний простір в цьому блоці.
            Покажчик allocp буде вказувати на перший не зайнятий елемент блоку. Якщо звертаються до allocp для виділення
            n символів, вона перевіряє чи залишилось в allocbuf достатньо місця для цього масиву. Якщо залишилось, тоді
            функція видає поточне значення allocp, а потім збільшує його значення на n. Після цього allocp знову буде
            вказувати на вільний блок. Функція ж free(p) присвоює значення p покажчику allocp, якщо p вказує всередину
            allocbuf:
            #define NULL 0 /* значення, яке буде сигналізувати про помилку */
            #define ALLOCSIZE 1000 /* об’єм доступної пам’яті */
            static char allocbuf [ ALLOCSIZE ]; /* пам’ять для allocp */
            static char *allocp=allocbuf; /* чергове вільне місце */
            char *alloc(n)
            int n;
            { if (allocp+n &amp;amp;lt;=allocbuf+ALLOCSIZE) { /* місце є */
            allocp+=n;
            return (allocp-n);
            } else /* місця немає */
            return (NULL);
            }
            free(p) /* звільняє пам’ять по p */
            char p;
            { if (p&amp;amp;gt;=allocbuf &amp;amp;&amp;amp; p&amp;amp;lt;allocbuf+ALLOSIZE)
            allocp=p;
            }.
            В загальному випадку покажчик можна ініціювати так як і довільну іншу змінну. Але осмисленим є тільки одне
            значення  NULL, або значення виразів, які містять адреси попередньо визначених даних відповідних типів.
            Опис
            static char *allocp=allocbuf;
            визначає змінну allocp, як покажчик на символ і ініціює її значенням, яке вказує на allocpbuf, як на чергове
            вільне місце на початку роботи програми.
			</text>
			 </sub_item>
				<sub_item>
				<item_title>  7.6. Символьні покажчики і функції</item_title>
				<text>
            
            Довільну символьну константу можна трактувати як масив символів, який закінчується нуль-символом, і тому
            займають в пам’яті на один символ більше ніж вказано в подвійних ланках. Якщо стрічка символів зустрічається
            в програмі, тоді звернення до неї йде через покажчик на її початок. В мові Сі немає жодної операції яка б
            дозволяла працювати зі стрічками символів окремо, як з єдиним цілим.
            Для ознайомлення з технікою роботи з покажчиками і масивами розглянемо дві стандартні функції із стандартної
            бібліотеки вводу-виводу.
            Перша функція strcpy(s,t) копіює стрічку t в стрічку s. Розглянемо версію базовану на масивах.
            strcpy(s, t)
            char s[], t[];
            { int i;
            i = 0;
            while (( s[i]=t[i])!=‘\0’)
            i++;
            }
            і версію з покажчиками
            strcpy(s, t)
            char *s, *t;
            { while ((*s=*t)!=‘\0’)
            { s++; t++;}
            }
            але з практичної точки зору її можна було б покращити так:
            strcpy(s, t)
            char *s, *t;
            { while (( *s++=*t++)!=‘\0’
            ;
            }
            або ж
            strcpy(s, t)
            char *s, *t
            { while ( *s++=*t++ )
            ;
            }
            Друга функція strcmp(s,t), порівнює стрічки s і t і видає від’ємне, нульове і додатне число в залежності від
            того, чи буде s менше рівне або більше t згідно лексикографічного порядку відповідно. Значення яке повертає
            функція в функцію виклику отримується шляхом обчислення різниці між першими символами стрічок, які не
            співпадають.
            Варіант з масивами:
            strcmp(s, t)
            char s[], t[];
            { int i;
            i =0;
            while (s[i] = = t[i])
            if s[i++] = = ‘\0’ return 0;
            return ( s[i]-t[i]);
            }
			</text>
			 </sub_item>
				<sub_item>
				<item_title>   7.7. Багатомірні масиви</item_title>
				<text>
           
            Очевидно, що багатомірні масиви тісно зв’язані з масивами покажчиків. Розглянемо задачу про перетворення
            дати в вигляді дня і місяця в день року і навпаки. Наприклад 1 березня  60-й день невисокосного року і 61-й
            день високосного. Для такого перетворення визначимо відповідно дві функції dayofyear і monthday. Оскільки
            остання функція повинна повертати два значення, тоді відповідні аргументи повинні бути покажчиками.
            Цим функціям потрібна таблиця чисел про кількість днів в місяцях. Тому, що число днів в місяцях залежить від
            високосного року, і щоб не ускладнювати програму аналізом кількості днів в лютому, введемо двовимірний
            масив.
            static int day_tab [2] [13] = {
            { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
            { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
            }
            dayofyear ( year, month, day )
            int year, month, day;
            { int i, leap;
            leap=year%4 = = 0 &amp;amp;&amp;amp; year%100!=0 | | year%400 = = 0;
            for (i=1;yearday&amp;amp;gt;day-tab[ leap ] [i]; i++)
            yearday-=day_tab[leap] [i];
            *pmonth=i;
            *pday=yearday;
            }
            Це перший двомірний масив який ми використали в Сі. Згідно визначення, двомірний масив  це одномірний масив
            елементи якого є масивами. Тому маємо особливість запису day_tab[ ][ ]. Чотири квадратні дужки підкреслюють
            таке визначення. Елементи масиву зберігаються по стрічкам. Якщо б масив day_tab потрібно було передавати в
            функцію як параметр, тоді опис цієї функції мав би такий вигляд:
            f(day_tab)
            int day_tab [2] [13];
            {. . .}.
            Опис аргументу f можна зробити і таким int day_tab [] [13], тому що розмір стовпців не має значення.
            Використовуючи покажчики був би можливий такий опис:
            int (*day_tab) [13].
			</text>
			 </sub_item>
				<sub_item>
				<item_title>  7.8. Масиви покажчиків</item_title>
				<text>
            
            Тому, що покажчики є змінними, можна вважати, що будуть використовуватись і масиви покажчиків. Розглянемо
            приклад такого застосування. Нехай нам потрібно написати програму для впорядкування в лексикографічному
            порядку множини стрічок тексту, це буде спрощений варіант сервісної програми sort із системи UNIX.
            Ми маємо справу зі стрічками тексту, які різняться довжиною і їх неможливо порівнювати і пересилати однією
            операцією. Виберемо таку структуру даних, яка б дозволила зручно і ефективно працювати з текстовими
            стрічками змінного розміру. В якості такої структури розглянемо масив покажчиків. Якщо збереження стрічок
            організовано так що стрічки знаходяться щільно одна за іншою в одному довгому символьному масиві, тоді до
            кожної стрічки можна добиратись з допомогою покажчика на її перший символ. Самі покажчики будемо зберігати в
            деякому масиві. Порівнювати дві стрічки можна з допомогою функції strcpm, передаючи їй покажчики на них.
            Якщо потрібно переставити місцями дві стрічки, то переставляються покажчики на них, а не самі стрічки.
            Процес впорядкування включає три етапи:
            читання всіх стрічок на вході;
            їх впорядкування;
            друк в визначеному порядку.
            Тому напишемо функції для реалізації відповідного етапу і головну програму, яка буде керувати ними.
            Проаналізуємо дії, які програма повинна виконувати по вводу стрічок. Функція вводу повинна збирати і
            зберігати символи кожної стрічки, а також будувати масив покажчиків до цих стрічок. Побіжною роботою можна
            вважати підрахунок кількості стрічок. Остання інформація потрібна для організації, впорядкування і друку.
            Якщо стрічок буде надто багато, функція вводу може видавати значення від’ємне, наприклад -1.
            #define NULL 0
            #define LINES 100 /* максимальна кількість стрічок */
            main()
            {
            char *lineptr[LINES]; /* покажчик и на стрічки тексту */
            int nlines; /* число прочитаних стрічок */
            if (( nlines=readlines(lineptr, LIMES))&amp;amp;gt;=0)
            { sort(lineptr, nlines);
            writelines(linepert, nlines);
            }
            else
            printf(“input too big to sort\n”);
            }
            #define MAXLEM 1000
            readlines(lineptr, maxlines) /* читання стрічок */
            char*lineptr[];
            int maxlines;
            {
            int len, nlines;
            char *p, alloc(), line[MAXLEM];
            nlines=;
            while((len=getline(line, MAXLEM))&amp;amp;gt;)
            if(nlines&amp;amp;gt;=maxlines) return(-1);
            else if ((p=allocp(len))==NULL) return(-1);
            else {line[len-1]=‘\0’; /* нова стрічка */
            strcpy(p, line);
            lineptr [nlines++]=p;
            }
            return(nlines);
            }
            Перехід на нову стрічку в кінці кожної стрічки відкидається і тому не впливає на порядок сортування.
            writelines(lineptr, nlines)
            char *lineptr[];
            int nlines;
            { int i;
            for i=0; i&amp;amp;lt;nlines; i++)
            printf (“%s\n”, lineptr[i]);
            }
            Тут нам зустрівся повний опис char *lineptr[lines]; він каже, що lineptr масив, елементи якого є покажчиками
            на величини типу char. Всього таких елементів lines. Отже, lineptr[i] - покажчик на символ, а *lineptr[i]
            дає доступ до самого символу.
            Тому, що lineptr - масив, який передається в якості параметру функції, його можна трактувати як покажчик, і
            функцію можна переписати так:
            writelines(lineptr, nlines)
            char *lineptr [];
            int nlines;
            { while(  nlines&amp;amp;gt;=0)
            printf (“%s\n”, *lineptr++);
            }
            Перейдемо до самого впорядкування:
            sort(v, n) /* впорядкування стрічок v[0], --, v[n-1] */
            char *v[];
            int n;
            { int gap, i, j;
            char *temp;
            for (gap=n\2; gap&amp;amp;gt;0; gap/=2)
            for (i=gap; i&amp;amp;lt;n, I++)
            for (j=i-gap;j&amp;amp;gt;=; j-=gap)
            { if (strcp(v[j], v[j+gap])&amp;amp;lt;=0)
            brealn;
            temp=v[j];
            v[j]=v[j+gap];
            v[j+gap]=temp;
            }}

            Три цикли реалізують “капельковий” метод впорядкування.
            При першому знайомстві з Сі іноді виникають проблеми з трактуванням різниці між двомірними масивом і масивом
            покажчиків. Наприклад, якщо є опис
            int a[10] [10];
            int *b[10];
            то звернення a[5][5] і b[5][5] є допустимими. Але а  є дійсно масивом, для якого виділено 100 комірок
            пам’яті, і для визначення потрібного елементу виконуються звичайні індексні обчислення, які враховують
            “прямокутність” масиву. Опис b вимагає виділення в пам’яті тільки 10 покажчиків, і кожний з них потрібно так
            встановити, щоб він вказував на масив цілих величин. Якщо припустити, що кожний покажчик вказує на масив із
            десяти елементів, тоді буде зайнято 100 комірок пам’яті під ці масиви плюс іще десять комірок на покажчики.
            Отже, масиви покажчиків займають трішки більше пам’яті і можуть вимагати явного ініціювання. Але такі масиви
            мають і дві переваги: доступ до елементу іде через покажчик і не потребує операцій обчислення; стрічки
            масиву (вектори) можуть бути різного розміру.
			</text>
			 </sub_item>
				<sub_item>
				<item_title>  7.9. Покажчики і багатовимірні масиви</item_title>
				<text>
            
            
            Як створювати покажчики для багатовимірних масивів? Щоб знайти відповідь на це питання, розглянемо декілька
            прикладів. Припустимо, що ми маємо опис
            int zippo [4] [2]; /* масив типу int: 4 стрічки 2 стовпці */
            int *pri; /* покажчик на цілий тип */
            Тоді на що вказує pri = zippo? На перший стовпець першої стрічки: zippo= =&amp;amp;zippo [0][0]. А на що
            буде вказувати pri+1? На zippo [0][1] чи на zippo [1][0]? Відповідь на поставлене питання випливає із місця
            розміщення масиву в пам’яті. Двомірний масив розміщується, як і одномірний, в послідовних комірках пам’яті.
            Порядок елементів визначається тим, що самий правий змінюється першим, і наступні елементи масиву
            розміщуються так:
            zippo[0][0] zippo[0][1] zippo[1][0] zippo[1][1] zippo[2][0].
            Спочатку запам’ятовується перша стрічка, за нею друга і т. д. Таким чином:
            pri = = &amp;amp;zippo [0][0] /*1-а стрічка, 1-й стовпець */
            pri +1 = = &amp;amp;zippo [0][1] /* 1-а стрічка, 2-й стовпець */
            pri +2 = = &amp;amp;zippo [1][0] /* 2-а стрічка, 1-й стовпець */
            pri +3 = = &amp;amp;zippo [1][1] /* 2-а стрічка, 2-й стовпець */
            Добре, а на що ж буде вказувати pri+5? Вірно - на zippo [2][1].
            Ми описали двомірний масив як масив масивів. Якщо zippo є ім’ям нашого двомірного масиву, тоді якими будуть
            імена чотирьох стрічок, кожна з яких є масивом із двох елементів? Ім’я першої стрічки буде zippo[0], другої
            zippo[2] і т.п. Але ім’я масиву є також покажчиком на цей масив, вказує на його перший елемент. Тому:
            zippo [0] == &amp;amp; zippo [0] [0]
            zippo [1] == &amp;amp; zippo [1] [0]
            zippo [2] == &amp;amp; zippo [2] [0]
            zippo [3] == &amp;amp; zippo [3] [0]
            Ця властивість використовувати засоби, які орієнтувались на використання одномірного масиву і для двомірних
            масивів. Наприклад, воно дозволяє використовувати функцію, яка використовувалась для роботи з одномірним
            масивом, застосовувати і для двомірного масиву! Розглянемо програму знаходження середнього значення:
            /* одномірна функція. Двомірний масив */
            main()
            { static int juuh [3] [4] = { {2, 4, 6, 8}
            {100, 200, 300, 400}
            {10, 40, 60, 90}
            };
            int row;
            for (row=0; row&amp;amp;lt;3; row++)
            printf (“Середнє стрічки %d дорівнює %d\n”,
            row, mean( juuh[row], 4 );
            }
            int mean(array, n) /* знаходить середнє в одномірному масиві */
            int array [], n;
            { int index;
            long sum;
            if (n&amp;amp;gt;0) { for (index=, sum=0;index&amp;amp;lt;n;index++)
            sum +=(long) array[index];
            return ((int) (sum/n));
            else { printf (“Не має масиву \n”);
            printf (0);
            }
            }
			</text>
			 </sub_item>
				<sub_item>
				<item_title>  7.10. Зовнішні аргументи</item_title>
				<text>
            
            В мові Сі є можливість передавати аргументи і параметри програми на початку її виконання за рахунок обробки
            завдання написаного за допомогою мови керування завданнями. При обробці програми main їй передаються два
            аргументи. Перший, його називають argc, це кількість командних аргументів при звертанні до програми. Другий
            (argv) - покажчик на масив символьних стрічок, які містять потрібні аргументи. Робота з такими стрічками йде
            за допомогою багаторівневих покажчиків.
            Розглянемо програму echo, яка “повертає” командні аргументи, друкуючи їх в стрічку і розділяючи проміжками.
            Отже, якщо дамо команду
            echo hello , world
            тоді повинно бути надруковано
            hello , world .
            Значенням argv[0] завжди буде ім’я під яким викликалась програма, тому argv ніколи не буває меншим за 1 . В
            нашому прикладі argc=3, де argv[0]=“echo” , argv[1]=“hello”, argv[2]=“world” .Програма прийме вигляд:
            main(argc, argv)
            int argc ;
            char *argv[];
            { int I;
            for (I=1; i&amp;amp;lt;argc; I++)
            printf(“%s %c”, argv[i], (I&amp;amp;lt; argc-1)? ‘ ‘ : ‘ \n’);
            }
            Тіло нашої програми може бути переписане так :
            { while (--argc &amp;amp;gt;0 )
            printf(“%s %c” , * ++ argv, (argc&amp;amp;gt; 1) ? ‘ ‘: ‘ \n’);
            }
            або ж :
            { while (--argc &amp;amp;gt;0 )
            printf((argc&amp;amp;gt; 1) ?”%s” : “%s\n”, * ++ argv);
            }
            В останньому варіанті демонструється той факт, що форматний аргумент для printf може бути виразом.
            Часто аргументи командних стрічок використовуються для вказівки можливостей програми. Традиційно
            альтернативи задаються за допомогою дефіса і букви. Ці прапорці фактично нічого не визначають в Сі, - ми
            повинні самі програмувати їх розпізнання і обробку. Наприклад введемо прапорець - r, який буде вказувати
            програмі, що сортування потрібно зробити в зворотному порядку. Тоді ми повинні організувати його обробку:
            # define YES 1
            # define NO 0
            main (argc, argv)
            int argc ;
            char * argv[];
            { float array[100];
            int n;
            int flag=NO;
            if(argv[1][0]==‘-’&amp;amp;&amp;amp; argv[1][1]==‘r’)
            flag=YES;
            . . .
            if flag=NO sort(array, n);
            else sort2(array, n);
            . . .
            }
            Аргументи командних стрічок можуть також бути іменами файлів, і ви можете використовувати їх замість
            операторів перемикання, щоб вказати програмі над якими файлами їй потрібно працювати .
			</text>
			 </sub_item>
				<sub_item>
				<item_title>  7.11. Покажчики на функції</item_title>
				<text>
            
            В Сі з ім’ям функції не можна працювати як з якоюсь змінною, але можна це реалізувати через покажчик на
            функцію. З ним можна вже маніпулювати як з змінною. Можливість такої роботи ми продемонструємо на прикладі
            процедури впорядкування. Серед параметрів введемо варіантний аргумент -n, якщо він присутній то вхідні
            стрічки впорядковуються не в лексикографічному порядку а в числовому.
            Впорядкування складається з трьох основних частин  порівняння, перевірка впорядкованості любої пари
            об’єктів; переміщення, зміни їх місцезнаходження; і алгоритму впорядкування, який описує порядок виконання
            порівнянь і переміщень. Алгоритм впорядкування не залежить від операцій порівняння і зміни, тому передаючи
            йому різні функції порівняння і перестановки, ми можемо налагоджувати програму на різні алгоритми
            впорядкування. Цей підхід ми будемо використовувати в нашій програмі.
            Функція strcmp робить лексикографічне порівняння двох стрічок. а їх переміщення реалізує функція swap. Для
            числового порівняння двох стрічок і видачі числового коду аналізу будемо використовувати функцію numcmp. Всі
            ці функції описуються в програмі main і покажчики на них передаються в sort. Функція sort звертається в свою
            чергу, до цих функцій, але вже через покажчики.
            #define LINES 100 /*максимальна кількість стрічок впорядкування */
            main (arge,argv) /* сортування стрічок */
            int argc;
            char *argv[ ];
            { char *lineptr[LINES]; /* покажчики на стрічки */
            int ulines; /* число прочитаних стрічок */
            int strcmp(), numcnp(); /* функції порівняння */
            int swar(); /* функція обміну, переміщення */
            int numeric=0; /* або не 1, якщо впорядкування числове */
            if (argc&amp;amp;gt;1 &amp;amp;&amp;amp; argv[1][0]==‘-’ &amp;amp;&amp;amp; argv[1][1]==‘n’)
            numeric=1;
            if ((nlines=readlines(lineptr,LINES))&amp;amp;gt;=0)
            { if (numeric)
            sort(lineptr,ulines,numcmp,swap);
            else
            sort(lineptr,ulines,strcmp,swap);
            writelines(lineprt,ulines);
            }
            else
            printf (“input too big to sort \n”);
            }
            Тут stramp, numcmp і swap - функції, в операції &amp;amp; не має потреби, аналогічно тому, як раніше не було
            в ній потреби і в випадку імен масивів. Транслятор орієнтований на передачу адрес функцій.
            Тоді функція sort буде мати вигляд:
            sort (v,u,comp,exch) /* впорядкування стрічок v[0]. . .v[n-1]*/;
            char *v[];
            int n;
            int (*comp((),(*exch)();
            {int gap,i,5;
            for (gap=n/2; gap&amp;amp;gt;0;gap/=2)
            for (i=gap; i&amp;amp;lt;n; i++)
            for (j=i-gap; j&amp;amp;gt;=0; j-=gap)
            { if ((*comp)(v[j],v[j+gap])&amp;amp;lt;=0)
            break;
            (*exch)(&amp;amp;v[j],&amp;amp;v[j+gap]);
            }
            }
            Звернемо вашу увагу ще раз на опис: int (*comp)().
            Він говорить, що comp є покажчиком на функцію, яка повертає ціле значення. Перша пара дужок потрібна тому,
            що без них опис
            int *comp() позначав би, що comp функція, яка повертає покажчик на ціле значення.
            Отже в цьому випадку всі дужки дуже важливі, тому що потрібним чином виділяють компоненти звертання.
            Реалізацію функцій strcmp, numcmp і swap ми залишаємо вам в якості вправи.
		</text>
			 </sub_item>
				
            Вправи і завдання до розділу 7:
            7.1.Написати функцію, яка :
            а)повертає скалярний добуток двох векторів довільної довжини, зображених цілими масивами.
            б)упорядковує елементи цілого масиву довільного розміру за зростанням шляхом перестановок елементів і
            повертає число, рівне кількості зроблених перестановок.
            в)повертає індекс елементу рядку s1, з якого починається підрядок, рівний рядку s2.
            7.2. Скласти функцію, яка за цілим номером повертає покажчик на рядок , в якому записано назву місяця з цим
            номером.
            7.3. У масиві символів довжиною 1000 записано слова, відокремлені одне від одного послідовностями символів
            ‘/0’. Написати фунцію:
            а)друкує всі слова з масиву ;
            б)одержує рядок і перевіряє чи є в масиві слово, записане в цьому рядку; якщо такого слова немає ,то дописує
            його за останнім словом масиву. Передбачити, що при дописуванні слів може відбутись переповнення масиву;
            в)одержує рядок із словом, якщо це слово в масиві є, то функція всі його символи в масиві замінює символом
            ‘/0’;
            г)ущільнює масив, замінюючи послідовності символів ‘/0’ одним символом ‘/0’ і зсуває слова ліворуч.
            7.4. Функція одержує покажчик на масив із 100 покажчиків, кожний з яких посилається на рядок. ”Впорядкувати”
            рядки в лексикографічному порядку, переставляючи не рядки, а покажчики на них.
            7.5. Записати варіанти функцій з передачею обчислювальних значень через параметри-покажчики і через зовнішні
            змінні, коли функція:
            а)за трьома дійсними числами, які задають сторони трикутника, обчислює його площу і периметр
            б)за цілими n&amp;amp;gt;7 розраховує цілі a ,b такі, що 5a + 3b =n та a+b є мінімальним.
            7.6.* Дано цілі M, N та вектор дійсних чисел X[1..N]. Знайти ціле число i (1 i N-M), для якого сума
            x[i]+...+x[i+M] найближча до нуля.
            7.7.* Дано два відсортованих у неспадному порядку масиви A[1,N] та B[1,M]. Отримати відсортований у
            неспадному порядку масив C[1,N+M], який складається з елементів масивів A та B (&amp;amp;quot;злити&amp;amp;quot;
            масиви A та B).
			 </sub_item>
			 
				<sub_item>
				<item_title> 8. Структури</item_title>
				<text>
            
            Структура - це об’єднання однієї або більше змінних, можливо, різних типів, в одну групу, яка для простоти
            роботи має одне ім’я.
            Структури використовують для організації складних даних в великих програмах. Тому, що вони в багатьох
            ситуаціях дозволяють групувати в єдине ціле поріднені між собою змінні та працювати з ними як з єдиним
            цілим, а не з окремими складовими. Структури також дозволяють створювати нові типи даних. Вони дуже близькі
            до записів в Паскалі.
            Нехай ви бажаєте надрукувати опис своїх книг. Ви повинні занести в нього різну інформацію про кожну книгу:
            її назву, прізвище автора, видавництво, рік видання, число сторінок, тираж і ціну. Можна було б створити Сім
            масивів для задання відповідної інформації. Але працювати з ними окремо і підтримувати загальну структуру
            дуже марудно. Значно легше було б мати один масив, кожний елемент якого містив би всю інформацію про книгу.
            Але який з типів даних може містить стрічки і числа одночасно? Відповіддю є дані типу структура. Розглянемо
            їх використання в нашому випадку. Введемо шаблон для книги:
            struct book
            { char title[50];
            char autor[30];
            char publish[20];
            year int;
            pages int;
            tir int;
            price float;
            }
            Службове слово struct починає опис структури, який складається із списку описів, взятого в фігурні дужки.
            Перше слово, яке стоїть після struct, book - є ім’ям, яке визначає тип цієї структури. Тип структури іменує
            таку структуру і надалі може використовуватись для скорочення деталей опису. Змінні, які зустрічаються в
            структурі (autor, publish,..., price), називаються елементами структури. Елемент структури, тип структури і
            звичайні змінні (не елементи структур) можуть мати одне й те ж ім’я. Конфліктів не буде, тому що з контексту
            зрозуміло про що йде мова.
            Зразу ж за закриваючою фігурною дужкою може йти список змін-них: struct{. . . } x,y,z. В цьому випадку
            оператор struct описує x, y, z як змінні іменованого типу і примушує виділити для них потрібну пам’ять. Опис
            структури без останніх змінних не виділяє пам’яті; він просто задає шаблон або форму структури. Якщо такий
            опис вводить ще й ім’я типу, тоді це ім’я можна пізніше використовувати при визначенні фактичних екземплярів
            цієї структури. Наприклад
            struct book b
            описує визначення змінної b, як структуру, аналогічну структурі з ім’ям book. Зовнішні або статичні
            структури можна ініціювати, розміщуючи за визначенням список початкових значень компонент. Доступ до
            елементів структури проходить за допомогою конструкції:
            ім’я структури. елемент.
            Розглянемо приклад застосування структур:
            /* інвентаризація однієї книги */
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #define MAXTIT 41 /* максимальна довжина назви */
            #define MAXАUT 31 /* максимальна довжина прізвища та ім’я */
            struct book
            { char title[MAXTIT]; /* назва книги */
            char autor[MAXАUT]; /* автор книги */
            float value; /* ціна книги */
            };
            main ()
            { struct book libry; /* опис змінної типу book */
            printf (“Введіть, будь-ласка, назву книги.\n”);
            gets (libry.title);
            printf (“Введіть прізвище і ініціали автора.\n”);
            gets (libry.autor);
            printf (“Введіть ціну книги.\n”);
            scanf (“%f”, &amp;amp;libry.value);
            }
            Отже, ви можете розміщувати шаблон або за межами функції, або в самій функції. Якщо ви встановили шаблон в
            функції, тоді він може використовуватись тільки в цій функції. Якщо ж шаблон розміщений зовні, тоді він
            доступний всім функціям програми, які розміщені за його визначенням.
            Шаблон є схемою без змісту; він повідомляє щось компілятору, але не викликає жодних змін в програмі. Дія
            наступає після визначення структурної змінної: struct book libry.
		</text>
			 
				<sub_item>
				<item_title> 8.1. Ініціювання структури</item_title>
				<text>
            
            Відмітимо, що належність структурної змінної зовнішньому типу залежить від того, де визначена змінна, а не
            де визначений шаблон. В нашому випадку шаблон book є зовнішнім, а змінна libry - внутрішньою, тому що вона
            визначена в середині функції і по замовченню належить до класу автоматичної пам’яті.
            Нехай ми створили такий опис:
            static struct book libry;
            Тоді використовується динамічна пам’ять, і можна ініціювати структуру:
            static struct book libry=
            { “Мова програмування Сі”,
            “Керніган Б., Pitri D”,
            6.50
            };
            Щоб зробити асоціації природними, ми дали кожному елементу свою власну стрічку ініціювання, не зважаючи на
            те, що компілятору потрібні тільки коми для відокремлення елементів ініціювання.
			</text>
			</sub_item>
			 
				<sub_item>
				<item_title> 8.2. Масиви структур</item_title>
				<text>
            
            Внесемо таку модифікацію в нашу програму, щоб вона дозволяла інвентаризувати багато книг. Для обробки
            декількох книг зробимо масив структур типу book:
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #define MAXTIT 40
            #define MAXАUT 40
            #define MAXBKS 100 /* max кількість книг */
            #define STOP “ ” /* для зупинки введення */
            struct book
            { char title[MAXTIT];
            char autor[MAXAUT];
            float value;
            };
            main ()
            struct book libry[MAXBKS]; /* масив структур */
            int count=0;
            int index;
            printf (“Введіть назву книги.\n”);
            printf (“Натисніть клавішу [ввод] на початку
            стрічки для зупинки вводу.\n”);
			</text>
			</sub_item>
			 
				<sub_item>
				<item_title> 8.3. Покажчики на структури</item_title>
				<text>

            
            Використання покажчиків з структурами бажане по трьом причинам: їх легше використовувати; структура не може
            використовуватись в якості аргументу функції, а покажчик на структуру може; багато типових структур даних є
            структурами які містять покажчики на інші структури. Розглянемо програму:
            /* покажчик на структуру */
            #define LEM 20
            struct names
            { char first [LEM];
            char last [LEM];
            };
            struct guy
            { struct names handle;
            char favfood [LEM];
            char job [LEM];
            float income;
            };
            main()
            {
            static struct guy fellow[2]={{ “Франко”,”Уотєл”},
            {“баклажан”, “художник”, 15 435.00},
            { “Родней”, “” },
            {“лососевий мусс”, “декоратор інтер’єра”,
            35000.00 }
            };
            struct guy *him; / *опис покажчика на структуру */
            printf (“адреса #1:%u #2: %u\n”, &amp;amp;fellow[0], &amp;amp;fellow[1]);
            him=&amp;amp;fellow[0];
            printf(“покажчик#1:%u #2:%u\n”, him, him+1);
            printf(“him&amp;amp;gt;прибуток $ %.2f : (*him).прибуток $%.2f\n”,
            him&amp;amp;gt;прибуток, (*him).прибуток );
            him++;
            printf(“him &amp;amp;gt; favfood is %s: him &amp;amp;gt; names.last
            is %s\n”, him&amp;amp;gt;favfood, him&amp;amp;gt;handle.last );
            }
            Якщо її заслати на виконання то можна отримати на виході подібне до цього:
            адреса #1: 12 #2:96
            покажчик #1: 12 #2:96
            him&amp;amp;gt; прибуток $15435.00: (*him).прибуток $15435.00
            him&amp;amp;gt;favfood лососьовий мусс: him&amp;amp;gt;names.last Свилбели.

            Нехай him  є покажчиком на структуру fellob, наприклад на fellow[0]. Можна виділити два способи
            використання покажчика him для отримання значення елементу структури fellow[0].
            Перший використовує нову операцію &amp;amp;gt;( дефіс “” і символ “&amp;amp;gt;”): him &amp;amp;gt;income
            це fellow[0].income
            Зазначимо також, що him-&amp;amp;gt;income буде в цьому випадку вже змінною типу float.
            Другий спосіб визначення значення елементу структури випливає із послідовності:
            якщо him == &amp;amp; fellow[0], тоді +him == fellow[0].
            Тому після підстановки матимемо:
            fellow[0].income == (*him).income.
            Останні дужки потрібні, тому що операція “.” має пріоритет вищий за операцію “*”.
            Отже, якщо him є покажчиком на структуру fellow[0], тоді наступні позначення будуть еквівалентними
            fellow[0].income == (*him).income = him&amp;amp;gt;income
			</text>
			</sub_item>
			 
				<sub_item>
				<item_title> 8.4. Передача інформації про структури функціям</item_title>
				<text>

            
            Згадаємо, що аргументи функції передають значення в функцію. Кожне значення є або числом типу int або float,
            або ж ASCII кодом або адресою. Структура більш складніша, тому її не можна використовувати в якості
            аргументу функції. Але є три основні способи передати інформацію про структуру в середину функції:
            1) використання елементів структури;
            2) використання адреси структури;
            3) використання масиву структури;
            Перший варіант простий і тому зрозумілий. Для ілюстрації другого підходу розглянемо програму фінансових
            розрахунків, яка добавляє внесок клієнта до його рахунку. Будемо використовувати адресу структури в якості
            аргументу. Цей варіант можливий, оскільки адреса виражається одним числом. Тому що функція повинна працювати
            з структурою funds, вона також повинна використовувати шаблон funds.
            /* передача адреси структури в функцію */
            struct funds
            { char *bank;
            float bankfund;
            char *save;
            float savefund;
            } stan =
            { “Банк Україна”
            1023.43,
            “Гроші Івана Кравченко”
            4239.87
            }
            main()
            { float total,sum();
            printf (“У Кравченка всього %.2f \n”,sum(&amp;amp;strn));
            }
            float sum(money)
            struct funds *money;
            { return (money &amp;amp;gt;bankfund+money&amp;amp;gt;savefund);
            }
            В результаті роботи програма надрукує:
            У Кравченка всього 5263.30 гривень.
            Функція sum має доступ і до назви банку, але її не використовує.
            Відмітимо, що ми повинні використовувати операцію &amp;amp; для отримання адреси структури. На відміну від
            імені масиву ім’я структури прямо не є синонімом своєї адреси.
			</text>
			 
				<sub_item>
				<item_title> 8.4.1. Використання масиву</item_title>
				<text>
            
            Нехай у нас є масив структур. Ім’я масиву є синонімом його адреси, тому його можна передати функції. З
            іншого боку, функції також потрібний доступ до структурного шаблону. Для того, щоб показати як працювати в
            цьому випадку, розширимо нашу програму введенням масиву двох структур funds для обслуговування двох осіб:
            /* передача масиву структур в функцію */
            struct funds {. . .
            } jones[2]={ {}, { “банк “Inko””,1000.00,
            “Гроші Марії Кравченко”
            2000.00 }
            }
            main()
            { float total,sum();
            printf (‘Кравченки мають разом %.2f гривень.\n”,
            sum(jones));
            }
            float sum(money)
            struct funds *money;
            { float total;
            int i;
            for (i=0, total=0; i&amp;amp;lt;2; i++, money++)
            total+=money-&amp;amp;gt;bankfund+money-&amp;amp;gt;savefund;
            return (total);
            }
            Ім’я масиву jones є покажчиком на масив, на перший елемент масиву, який є структурою jones[0]. Тому,
            спочатку money=&amp;amp;jones[0], потім використання операції -&amp;amp;gt; дозволяє просумувати два внески
            для Івана Кравченка. Використання циклу повторяє аналогічні дії для Марії.
            Відмітимо:
            1.Ім’я масиву можна використовувати для передачі в функцію покажчика на першу структуру в масиві.
            2.Подальший перебіг по структурам масиву роблять за допомогою арифметичних операцій над покажчиком.
			</text>
			 </sub_item>
				<sub_item>
				<item_title> 8.4.2. Використання структур</item_title>
				<text>
            
            Структури можуть активно використовуватись для створення нових типів даних - зв’язаних списків різної форми
            доступу і зв’язності: лінійні списки, циклічні списки, стеки, черги, дерева, графи [5,6].
            Розглянемо роботу з таблицями, характерною для обробки імен в макропроцесорах або трансляторах. Наприклад,
            розглянемо оператор define:
            #define YES 1
            Якщо аналізується така стрічка, тоді результатом є занесення імені YES та його значення 1 зберігаються в
            деякій таблиці. Далі, коли десь в програмі буде зустрічатись ім’я YES, воно завжди буде замінятись на 1.
            Існує дві основні програми для маніпулювання з іменами і текстами, що їх заміняють. Перша, install(s,t) -
            записує в таблицю ім’я s і текст t, який асоційований з ім’ям. Тут s і t стрічки символів. Друга, lookup(s),
            шукає s в таблиці, якщо ім’я було знайдене, результатом буде покажчик на це ім’я; якщо ж ім’я не було
            знайдене, повернеться покажчик рівний NULL.
            Будемо використовувати ідею алгоритму хешування: отримане ім’я асоціюється з невеликим додатнім цілим і це
            ціле потім використовується як індекс для масиву покажчиків. Елементи масиву вказують на початок ланцюжка
            блоків, які описують імена, що перетворились в одне ціле. Якщо покажчик дорівнює NULL, тоді імені з
            відповідним значенням цілого не було.
            Довільний блок в ланцюжку-це структура, яка складається із покажчика на ім’я, покажчика на текст заміщення і
            покажчика на наступний блок в ланцюжку. Пустий покажчик сигналізує про закінчення ланцюжку:
            struct nlist /* основна стрічка таблиці */
            { char *name;
            char *def;
            struct nlist *next;
            }
            Масив покажчиків можна описати
            #define HASHSIZE 100
            static struct nlist*hashtab[HASHSIZE];
            Функція хешування будується так: сумуються значення символів в стрічці по модулю розміру масиву:
            hash(s) /* формування hashval для стрічки s */
            char *s;
            { int hashval;
            for (hashval=0; *s!=‘0’;)
            hashval +=*s++;
            return (hashval %HASHSIZE);
            }
            Пошук імені буде проводитись програмою lookup:
            struct nlist *lookup(s) /* пошук s */
            char *s;
            { struct nlist *np;
            for (np=hashtab[hash(s)]; np!=NULL; np=np-&amp;amp;gt;next)
            if (strcmp(s, np-&amp;amp;gt;name)==0)
            return (np); /* знайдена */
            return (NULL); /* не знайдена */
            }
            Програма lookup використовується і в install. З її допомогою визначається чи не було раніше вже встановлено
            ім’я, про яке йде мова. Якщо це так, тоді нове визначення повинне замінити старе. В іншому випадку повністю
            формується нова стрічка таблиці. Якщо ж install видає NULL, тоді це означає ситуацію, коли для нової стрічки
            не залишилось місця:
            struct nlist *install(name,def) /* занести name, def */
            char *name,*def; /* в hashtab */
            { struct nlist *np,*lookup();
            char *strsave(),*alloc();
            int hashval;
            if ((np=lookup(name))==NULL) /* не знайдена */
            { np=(struct nlist*)alloc(sizeof(*np));
            if (np==NULL) return (NULL);
            if ((np-&amp;amp;gt;name=strsave(name))==NULL)
            return (NULL);
            hashval=hash(np-&amp;amp;gt;name);
            np-&amp;amp;gt;next=hashtab[hashval];
            hashtab[hashval]=np;
            }
            else
            free(np-&amp;amp;gt;def); /* звільнити старе визначення */
            if ((np-&amp;amp;gt;def=strsave(def))==NULL)
            return (NULL);
            return (np);
            }
            Функція strsave просто копіює стрічку, задану як параметр, в безпечне місце, яке отримується при зверненні
            до alloc.
			</text>
			 </sub_item>
			  </sub_item>
				<sub_item>
				<item_title> 8.5. Конструювання нових типів даних і структури</item_title>
				<text></text>
            
			<sub_item>
				<item_title> 8.5.1. Поля</item_title>
				<text>
            
            Якщо маємо дефіцит пам’яті, тоді може бути корисним пакування декількох об’єктів в одне машинне слово. Так
            часто роблять, згрупував однорозрядні признаки в задачах типу обробки таблиць імен для трансляторів. Формати
            даних, які залежать від типу обчислювального пристрою, і які визначаються, наприклад, інтерфейсом роботи з
            зовнішніми пристроями, також часто вимагають можливості виділення частин слів.
            Нехай, маємо справу з фрагментом транслятора, який маніпулює з таблицею імен. З кожним ідентифікатором
            програми пов’язана деяка інформація, наприклад: чи це службове слово, чи ні; чи це зовнішнє ім’я, чи ні і
            т.д. Найбільш компактний спосіб зашифрувати цю інформацію - задати її однорозрядними признаками в одному
            символі або цілому.
            Традиційно це робиться шляхом визначення множини “масок”, які відповідають послідовним розрядам. Наприклад,
            так:
            #define KEYWORD 01
            #define EXTERN AL 02
            #define STATIC 04
            Числа повинні бути степенями двійки. В цьому випадку звернення до розрядів іде за допомогою операцій зсуву,
            маскування і заперечення:
            Часто з’являються навіть деякі ідіоми:
            flags |=EXTERNAL | STATIC; тут “включаються” розряди із змінної flags, які відповідають EXTERNAL і STATIC.
            Вираз
            flags &amp;amp;= (EXTERNAL | STATIC);
            “вимикає” їх, а умова
            if ((flags &amp;amp;(EXTERNAL | STATIC))==0). . .
            дорівнює істині, якщо два розряди рівні нулю.
            Хоч з такими ідіомами навчитись працювати не важко, в Сі мається можливість безпосередньо, а не за допомогою
            логічних операцій визначення нулів, і доступ до них базується на відповідних поняттях про структуру.
            Наприклад, #define для попередньої програми, може бути замінене таким визначенням трьох полів:
            struct
            { unsigned is_keyword :1;
            unsigned is_extern :1;
            unsigned is_static :1;
            }
            flags;
            Тут визначається змінна з ім’ям flags, що містить три однорідні поля. Число, яке стоїть за двокрапкою, задає
            число розрядів в полі. Поля описуються за допомогою unsigned, щоб підкреслити, що ця величина без знаку.
            Тому приведені вище приклади можуть бути виражені більш природним чином:
            flags.is_extern=flags.is_static =1; встановлює розряди в 1;
            flags.is_extern=flags.is_static= 0; встановлює їх в 0, а
            if (flags.is_extern ==0) описує можливу перевірку. Поля не можуть переходити за межі цілого числа. Якщо
            розмір поля такий, що це повинно трапитись, тоді дане поле вирівнюється до межі наступного цілого числа.
            Існують деякі деталі, які відносяться тільки до полів. Найбільш властива з них пов’язана з тим, що на одних
            обчислювальних платформах поля розміщується в слові зліва направо, а в інших-справа наліво. Це наголошує на
            те, що якщо мова йде про роботу з даними, структура яких задана “ззовні”, тоді потрібно уважно придивлятися,
            з якого кінця слова вони починають розміщуватися. Потрібно також пам’ятати про те, що поля не мають знаку;
            їх можна зберігати лише в цілих або беззнакових змінних; не можуть бути масивами; не мають адрес, тому до
            них не можна застосовувати операцію &amp;amp;.
			</text>
            </sub_item>
			<sub_item>
				<item_title>  8.5.2. Суміші</item_title>
				<text>
           
            Суміш - це деяка змінна, яка може зберігати в різний час об’єкти різного типу і розміру. В цьому випадку
            транслятор зберігає інформацію про розмір і потрібне вирівнювання. Суміші дозволяють працювати в одній
            області пам’яті з даними різного типу.
            Розглянемо знову таблицю імен транслятору. Припустимо, що константи можуть бути типу int або float або ж
            покажчиками на стрічки. Значення кожної окремої константи повинно зберігатись в змінній потрібного типу,
            бажано займати один об’єм пам’яті і зберігатись в одному місці. Це можна зробити за допомогою суміші:
            union utag
            { int ival;
            float fval;
            char *pval;
            }
            uval;
            Змінна uval займає об’єм пам’яті потрібний для задання найбільшого з згаданих типів. Їй може бути присвоєне
            одне з трьох значень цих типів. Пам’ятати про те, значення якого з типів останній раз заносилось в змінну
            типу суміш покладається на програміста.
            Синтаксис звернення до елементів суміші виглядає так:
            ім’я суміші.елемент або
            покажчик на суміш -&amp;amp;gt;елемент
			</text>
            </sub_item>
			<sub_item>
				<item_title>  8.5.3. Визначення типу</item_title>
				<text>
           
            В мові Сі можна створити імена для нових типів даних. Для цього можна використати функцію визначення типу
            typedef:
            typedef float REAL;
            Отже функція typedef дозволяє створювати програмісту своє ім’я типу. Вона нагадує директиву #define, але має
            свої особливості:
            1. На відміну від define функція typedef дає символічні імена, але обмежується тільки типами даних;
            2. Функція typedef обробляється транслятором, а не процесором.
            Останній приклад говорить нам, що ми хочемо використовувати описувач REAL для чисел з плаваючою точкою:
            REAL x.y[25], *p;
            Область дії такого визначення залежить від місцезнаходження оператору typedef і подібне до опису любої
            змінної. Використання великих літер нагадує користувачу, що ім’я типу насправді є символьною абревіатурою:
            typedef char *STRING
            Такий опис без typedef визначав би STRING як покажчик на тип char, а в нашому випадку STRING є
            ідентифікатором покажчиків на тип char. Так
            STRING name,sign
            позначає
            char *name,*sign.
            Зверніть увагу, що тип опису в typedef з’являється не зразу за службовим словом typedef, а в позиції імені
            змінної. Синтаксично службове слово typedef подібне класу пам’яті extern, static і т.д.
            В якості більш складнішого прикладу використання typedef розглянемо визначення типу для гілок дерева:
            typedef struct tnode /* основна вершина */
            { char *word; /* текст */
            int count ; /* число входження тексту */
            struct tnode *left /* ліве піддерево */
            struct tnode *right /* праве піддерево */
            } TREENODE, *TREEPTR;
            Такий опис породжує два нових службових слова для типів : TREEMODE визначає структуру і TREEPTR - покажчик
            на цю структуру.
            Можна виділити дві основні причини використання typedef :
            1.Створення зручних для розпізнання імен типів.
            2.Імена typedef часто використовуються для складних типів. Наприклад опис
            typedef char *FRPTC() [5];
            об’являє тип FRPTC функцією, яка повертає покажчик на п’ятиелементний масив типу char.
			</text>
            </sub_item>
			</sub_item>
			
            Вправи і завдання до розділу 8:
            8.1.Написати функцію strcat(s1,s2), використовуючи покажчики.
            8.2. Написати функцію day_of_year, яка за порядковим номером дня в році видає його повну ідентифікацію.
            8.3. Напишіть програму add, яка обчислює математичний вираз, що записаний в зворотньому польському записі з
            командної стрічки.
            (приклад add 3 3 4 + * обчислюється як 2*(3+4)).
            8.4. Написати програму tail, яка друкує останні n стрічок вхідної інформації. По замовчуванні n=10, але його
            можна змінити варіаційним аргументом. Програма повинна працювати раціонально, не залежно від того, яка б
            безглузда не була вхідна інформація , або значення n.
            8.5.* Побудувати максимально можливу множину, яка складається з попарно не порівнювальних векторів v.
            Вектори v визначаються парами чисел, які обираються із заданої послідовності чисел а1, ..., аn , n 1. Два
            вектора v = (а,в) та v&amp;amp;apos; = (а&amp;amp;apos;,в&amp;amp;apos;) називаються порівнювальними, якщо а
            а&amp;amp;apos; та в в&amp;amp;apos; або а а&amp;amp;apos; та в  в&amp;amp;apos;, інакше вектори
            непорівнювальні.
            8.6.* В музеї протягом дня відбувається регістрація приходу та виходу для кожного відвідувача. Таким чином
            за день отримані N пар значень, де перше значення в парі показує час приходу відвідувача та друге значення -
            час його виходу. Знайти проміжок часу, на протязі якого в музеї одночасно знаходилося максимальне число
            відвідувачів.
			</sub_item>

			
			<sub_item>
				<item_title>  9. Бібліотека мови і файли вводу-виводу</item_title>
				<text>
            
            Кожний раз, коли ми використовуємо функції типу printf(), strln() ми звертаємось до бібліотеки мови Сі. Ця
            бібліотека містить велику множину функцій і макровизначень. Бібліотека може змінюватись в кожній версії
            реалізації Сі, але ядро функцій, яке ми називаємо стандартною бібліотекою залишається постійним.
			</text>
			<sub_item>
				<item_title>   9.1. Доступ в бібліотеку мови Сі</item_title>
				<text>
           
            Отримання доступу до бібліотеки мови залежить від системи реалізації. Можна виділити три основні способи
            доступу.
            1.Автоматичний доступ. В більшості систем UNIX ви повинні тільки відкомпілювати програму, а доступ до більш
            загальних бібліотечних функцій виконується автоматично.
            2.Включення файлу. Якщо функція задається як макровизначення, тоді можна директивою #include включити файл,
            який містить її визначення.
            3.Включення бібліотеки. На певному етапі компіляції чи завантаження програми ви можете вибирати бібліотеку
            включення, явно вказавши її ім’я.

			</text>
			</sub_item>
			<sub_item>
				<item_title>   9.2. Зв’язок з файлами</item_title>
				<text>
            
            Часто нам потрібно вміти читати вхідні дані із файлу або записувати результат роботи програми в потрібний
            файл. Один із способів організації зв’язку програми з файлом полягає в використанні операції переключання
            &amp;amp;lt; і &amp;amp;gt;. Цей метод простий але й обмежений. Наприклад, якщо наша програма prog читала
            символи з терміналу за допомогою функції getchar(), а зараз ми хочемо щоб вона читала ці символи із файлу
            infile, тоді ми повинні написати команду prog &amp;amp;lt; infile.
            Переключання вводу просте і в випадку коли вхідна інформація однієї програми приходить з вихідної інформації
            іншої програми використовуючи механізм “каналу”:
            prog1  prog2
            стандартний вхід для prog2 береться із стандартного виходу prog1. Якщо ж використати команду:
            prog &amp;amp;gt; outfile
            то вона викличе видачу стандартного потоку виходу програми prog в файл outline.
            Постає питання. Як мова Сі трактує поняття файлу? Вона розглядає файл як середовище зберігання інформації
            певної структури:
            struct iobuf
            { char *ptr; /* поточний покажчик буферу */
            int cut; /* поточний лічильник байтів */
            char *base; /* базова адреса буферу вводу-виводу */
            char flag; /* керуючий признак */
            char file /* номер файлу */ };
            #define FILE struct iobuf
            Останнє визначення говорить про те, що коротке ім’я шаблону файлу буде FILE. Виникає також проблема, як
            зв’язати зовнішні імена, які використовує користувач, з операторами, які фактично виконують читання.
            Правила прості. Спочатку, перед роботою з файлом його потрібно відкрити за допомогою стандартної
            бібліотечної функції fopen. Вона бере зовнішнє ім’я файлу (file.c), щось з ним робить і повертає внутрішнє
            ім’я, яке потім використовується під час запису або читання файлу.
            Внутрішнє ім’я - це покажчик на деяку структуру, в якій міститься інформація про файл: місцезнаходження
            буферу, позиція поточного символу в цьому буфері, признак стану файлу ( читається чи записується
            інформація). Тому потрібно описувати покажчики на файл:
            FILE *fopen(); *fp;
            fp-покажчик FILE, а fopen() видає цей покажчик. Звернення до fopen в програмі має вигляд:
            fp=fopen(name,mode);
            де name - ім’я файлу (стрічка символів), а mode - режим використання файлу (r- читання, w- запис, a-
            доповнення.
			</text>
			</sub_item>
			<sub_item>
				<item_title>   9.3. Буферизація</item_title>
				<text>
            
            Функції відкриття та закриття файлу працюють через буфер. Під буфером ми розуміємо тимчасову пам’ять в якій
            зберігаються дані вводу-виводу . Якщо буфер заповнюється тоді його зміст передається в блок передачі і
            процес буферизації починається спочатку. Одна з функції fсlose() заключається в &amp;amp;quot;звільненні&amp;amp;quot;
            всіх частково - замовлених буферів , якщо файл закритий .
            Для роботи з текстовим файлами (інформація запам’ятовується в вигляді символів коду ASCII ) використовують
            дві функції getc() і putc() . Їх робота аналогічна функціям getchar() і putchar() . Різниця заключається
            тільки в пому, що для нових функцій потрібно явно вказувати як вони працюють.
            Розглянемо наступну програму. В попередній програмі ім&amp;amp;apos;я файлу , який потрібно було вказати ,
            знаходилось в програмі. Але це не обов&amp;amp;apos;язково. Використовуючи аргументи командної стрічки,
            можна вказувати програмі ім&amp;amp;apos;я файлу, з яким хочемо працювати. В нашій програмі простого
            стиснення (залишається кожний третій символ ) так і зроблено. Результат роботи записується в новий файл, ім&amp;amp;apos;я
            якого будується із файлу введення приєднанням розширення red.
            / *програма стиснення */
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            main (arge , argv )
            int arge;
            {
            FILE *in , *out;
            int ch;
            static char name[20];
            int count=0;

            if (arge&amp;amp;lt;2) /*перевірка на наявність вхідного файлу */
            printf(&amp;amp;quot;Задайте ім&amp;amp;apos;я файлу вводу в якості аргументу,\n&amp;amp;quot;);
            else
            { if ((in=foren(arv[1].&amp;amp;quot;r&amp;amp;quot;))!=NULL)
            {strcpy(name,arv[1]; /* копіює ім&amp;amp;apos;я файлу в масив */
            strcat(name,&amp;amp;quot;.red&amp;amp;quot;); /* додає .red до імені файлу */
            out=forean(name,&amp;amp;quot;w&amp;amp;quot;); /* відкриває файл для запису */
            while((ch=getc(in))!=EOF)
            if(count++ %3==0)
            putc(ch,out); /*друкує кожний третій символ */
            fclose(in);
            fclose(out);
            }
            else
            printf(&amp;amp;quot;Не можливо відкрити файл \&amp;amp;quot;%s&amp;amp;quot;\n&amp;amp;quot;,argv[1] );
            }
            }
            Ми описали два покажчики типу FILE щоб у нас одночасно були відкриті два файли. Кожний файл повинен
            відкриватись і закриватись незалежно від інших. Кількість одночасно відкритих файлів обмежена, залежить від
            типу системи, і лежить в межах від 10 до 20.
			</text>
			</sub_item>
			<sub_item>
				<item_title>  9.4. Основні бібліотечні функції роботи з файлами</item_title>
				<text></text>
            
			<sub_item>
				<item_title>  9.4.1. Форматне введення-виведення</item_title>
				<text>
            
            Якщо нам при роботі з файлами потрібне форматне введення-виведення, то тоді бажано використовувати функції
            fprintf() і fscanf(). Для них потрібний додатковий аргумент для посилання на файл, який ставиться першим у
            списку аргументів. Наприклад:

            /* зразок використання fprintf() і fscanf() */
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            {
            FILE *fi;
            int age
            fi=foren(&amp;amp;quot;sam&amp;amp;quot;,&amp;amp;quot;r&amp;amp;quot;); /*відкриває на читання */
            fscanf(fi,&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;age); /*вказує на sam */
            fclose(fi);
            fi=foren (&amp;amp;quot;data&amp;amp;quot;,&amp;amp;quot;a&amp;amp;quot;); /*доповнення */
            fprintf(fi,&amp;amp;quot;sam is %d.\n&amp;amp;quot; ,age); /*fi вказує на data*/
            fclose(fi);
            }
			</text>
            </sub_item>
			<sub_item>
				<item_title>  9.4.2. Функція fgets()</item_title>
				<text>
            
            Ця функція залежить від трьох аргументів :
            1-й - є покажчиком на місце знаходження стрічки читання ;
            2-й - містить граничну довжину стрічки читання ;
            3-й - вказує файл читання .
            Різниця між gets() і fgets() заключається в тому, що gets() заміняє символ нової стрічки на &amp;amp;apos;/0&amp;amp;apos;,
            а fgets() зберігає символ нової стрічки. Функція fgets() повертає значення NULL , коли зустрічає символ EOF.
            Розглянемо приклад читання файлу по стрічкам:
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #defane MAXLIN 80
            main()
            { FILE *fi
            char *string[MAXLIN];
            fi=foren(&amp;amp;quot;story&amp;amp;quot; , &amp;amp;quot;r&amp;amp;quot;);
            while( fgets(string, MAXLIN, fi)!=NULL)
            puts(string);
            }
			</text>
            </sub_item>
			<sub_item>
				<item_title>    9.4.3. Функція fputs()</item_title>
				<text>
          
            Має вигляд fputs(покажчик строчки , покажчик файлу) і працює аналогічно puts().
			</text>
            </sub_item>
			<sub_item>
				<item_title>   9.4.4. Функція fseek()</item_title>
				<text>
          
            
            Ця функція дозволяє обробляти відкритий файл подібно масиву, надаючи доступ до довільного байту файла. Вона
            має три аргументи: 1-й є покажчиком на файл; 2-й - повідомляє як далеко від початкової точки ви хочете
            пересунутись в файл (він повинен мати значення типу long). Якщо значення додатне - тоді просування вперед, а
            якщо значення від&amp;amp;apos;ємне - тоді назад; 3-й аргумент є кодом визначення початкової точки: 0 -
            початок файлу; 1 - поточна позиція; 2 - кінець файлу.
            Функція fseek() повертає 1, якщо все працює правильно і -1 , якщо трапилась якась помилка. Розглянемо
            програму:
            #include&amp;amp;lt;stydio.h&amp;amp;gt;
            main (number,names) /* не потрібно використовувати argc і argv */
            int number;
            char *names [];
            { FILE *fp;
            long offset=OL ; /* зверніть увагу на тип long */
            if (number&amp;amp;lt;2)
            puts(“Потрібно ім’я файлу в якості аргументу%s.\n “)
            else
            { if ((fp=fopen(names [1] , “r”))==0)
            printf(“Неможна відкрити %s.\n” , names [1]);
            else
            { while(fseek (fp , offset++,0)==0)
            putchar( gets(fp));
            fclose(fp);
            }
            }
            }
            Зупинимось на роботі циклу while. Оскільки змінна offset ініціюється 0 , при першому проході через цикл
            маємо fseek(fp,OL,0), що означає входження в файл, на який вказує покажчик fp і знайдемо байт, що зміщений
            на 0 байтів від початку. Потім putchar() друкує його значення. Потім offset збільшується до 1L і друкується
            наступний байт. Процес продовжується поки не досягнемо кінця файлу. В цьому випадку fseek() повертає - 1 і
            цикл закінчується.
			</text>
            </sub_item>
			</sub_item>
			<sub_item>
				<item_title>   9.5.Вмонтовані функції розподілу пам’яті</item_title>
				<text>
          
            При виконанні програми, вона повинна надавати достатній об’єм пам’яті для даних. Для деяких даних пам’ять
            розподіляється автоматично. Наприклад, об’явимо
            char plase[] = “Києво-Могилянська академія”;
            тоді буде виділена пам’ять, достатня для запам’ятовування цієї стрічки. Але ми можемо бути більш конкретними
            і запросити новий об’єм пам’яті:
            int plates[100] ;
            Цей опис виділяє 100 копірок пам’яті , кожна з яких призначена для запам’ятовування цілого значення. Мова Сі
            дозволяє нам розподіляти додаткову пам’ять під час роботи програми. Нехай, наприклад, ви пишете діалогову
            програму і не знаєте попередньо, скільки даних вам прийдеться вводити. Можна виділити потрібний вам об’єм
            пам’яті, а потім, якщо знадобиться, попросити іще. Це можна зробити за допомогою функції malloc() .
            /*додати пам’ять , якщо необхідно */
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #define STOP” “ /* сигнал зупинки вводу */
            #define BLOCK 100 /* байти пам’яті */
            #define LIM 40 /* гранична межа стрічки вводу */
            #define MAX 50 /* max кількість стрічок вводу */
            #define DRAMA 20000 /* затримка часу */
            main()
            { char store [BLOCK] ; /* початковий блок пам’яті */
            char symph[LIM]; /* буфер вхідних стрічок */
            char *end; /* вказує на кінець пам’яті */
            char *starts[MAX]; /* вказує на початок стрічки */
            int index=0 /* кількість стрічок вводу */
            int count; /* лічильник */
            char *malloc(); /* розподільник пам’яті */
            starts[0]=store;
            end=starts[0]+BLOCK-1;
            puts(“ Наведіть декілька футбольних команд“);
            puts(“Введіть по одному : натисніть клавішу [Enter]на початку “);
            puts(“стрічки для завершення вашого списку “);
            while(strcmp(fgets(symph,LIM,stdin),STOP)!=0 &amp;amp;&amp;amp; index&amp;amp;lt;MAX)
            { if(strlen(symph)&amp;amp;gt;end_starts[index])
            { /*дія при недостачі пам’яті запам’ятовування даних вводу */
            puts(“Почекайте. Виділимо додатково пам’ять “);
            starts[index]=malloc(BLOCK);
            end=starts[index]+BLOCK-1;
            for(count=0; count&amp;amp;lt;DRAMA;count++);
            puts(“ Трохи знайдемо“);
            }
            strcpy(starts[index],symph);
            starts[index+1]=starts[index]+strlen(symph)+1;
            if(++index&amp;amp;lt;MAX)
            printf(“ Це %d .Продовжуйте , якщо бажаєте .\n”,index);
            }
            puts(“ Добре , виділено:“);
            for(count=0; count&amp;amp;lt;index; count++)
            puts(starts[count]);
            }
            Розглянемо, що робить функція malloc(). Вона бере аргумент в вигляді цілого без знаку, яке визначає потрібну
            кількість байтів пам’яті. Функція повертає покажчик на тип char на початок нового блоку пам’яті. Ми
            використали опис: char *malloc(); щоб попередити компілятор, що malloc() повертає покажчик на тип char. Іншу
            можливість розподілу пам’яті дає застосування функції calloc():
            char *calloc();
            long *newmem;
            newmem = (long *) calloc(100, sizeof (long));
            Ця функція має два аргументи цілого типу без знаку. Перший аргумент визначає кількість потрібних комірок
            пам’яті. Другий аргумент - розмір кожної комірки пам’яті в байтах. В кожному випадку long використовує в
            цілому 400 байтів пам’яті. Використавши sizeof(long) замість 4 , ми зробимо програму більш мобільною.
            Функція calloc() має ще одну особливість; вона обнулює вміст всього блоку.
			</text>
            </sub_item>
			</sub_item>
			
			
			<sub_item>
				<item_title>   10. Препроцесор мови Сі</item_title>
				<text>            
            Препроцесор проглядає програму до компілятора і замінює символьні абревіатури в програмі на відповідні
            директиви. Він відшукує потрібні нам файли, може змінити умови компіляції і т. п.
			</text>
			
			<sub_item>
				<item_title>  10.1. Символьні константи: #define</item_title>
				<text> 
            
            Директива #define може з’явитися в любому місці файлу, а визначення, яке вона дає, розповсюджується до кінця
            цього файлу. Ми вже використовували її для визначення символьних констант, але вона має більш широке
            застосування:
            /*Приклади директиви */
            #define TWO 2
            #define MSG “Помилка вводу“
            #define FOUR TWO*TWO
            #define PX printf(“X дорівнює %d.\n”,X)
            #define FMT “X дорівнює %d.\n”
            main()
            { int X=TWO;
            PX;
            X=FOUR;
            printf(FMT, X);
            printf(“%s\n”, MSG);
            printf(“TWO: MSG\n”);
            }
            Кожна стрічка директиви складається з трьох частин: #define , далі абревіатура (макровизначення) і стрічка
            заміщення. Коли препроцесор знаходить в програмі одне із вищих макровизначень він майже завжди замінює його
            стрічкою заміщення. Більшість систем дозволяють використовувати ‘\’ для розширення визначення більш ніж на
            одну стрічку.
			</text>
			</sub_item>
			<sub_item>
				<item_title>  10.2. Використання аргументів з #define</item_title>
				<text> 
            
            Макровизначення з аргументами дуже подібне на функцію, оскільки його аргументи заключаються в дужки:
            /* макровизначення з аргументами */
            #define SQUARE(x) x*x
            #define PR(x) printf(“x дорівнює %d.\n” , x)
            main()
            { int x=y;
            int z;
            z=SQUARE(x);
            PR(z);
            z= SQUARE(z);
            PR(z);
            PR(SQUARE(x));
            PR(SQUARE(x+2));
            PR(100/ SQUARE(2));
            PR(SQUARE(++x));
            }
            Коли запустимо програму на виконання, отримуємо:
            z дорівнює 16
            z дорівнює 16
            SQUARE(x) дорівнює16
            SQUARE(x+2) дорівнює 14
            100/SQUARE(2) дорівнює 100
            SQUARE(++x) дорівнює 30
            Перші дві стрічки зрозумілі. Відмітимо, що навіть всередині подвійних лапок в визначенні PR змінна
            заміняється відповідним аргументом. Всі аргументи в цьому визначенні заміняються. Третя стрічка
            PR(SQUARE(x)); становиться:
            printf(“SQUARE(x) дорівнює %d.\n”, SQUARE(x) );
            після першого стану макророзширення. Друге SQUARE(x) розширюється, перетворюючись на х*х, а перше
            залишається без змін, тому що зараз воно знаходиться в середині подвійних лапок в операторі програми, і
            таким чином захищене від подальшого розширення. Тому далі маємо:
            printf(“SQUARE(x) дорівнює %d.\n”, SQUARE(x*х) );
            Розглянемо наступний результат 14 . Згадаємо, що х=4 . Це дозволяє припустити, що SQUARE(x+2) буде рівне 6*6
            або ж 36 . Але маємо 14 . Чому ж? Відповідь дуже проста: препроцесор не робить обчислення, він тільки
            заміняє стрічку. Тому х*х стане х+2*х+2. Пiдставимо значення 4: 4+2*4+2=4+8+2=14.
            Останній приклад ілюструє важливу відмінність між викликом функції і макровикликом. Виклик функції передає
            значення агументу в функцію під час виконання програми. Макровиклик передає стрічку аргументів в програму до
            її компіляції.
            Багато задач можна вирішити використовуючи або макровизначення з аргументами або ж функцію. Ви повинні
            пам’ятати, що використання макровизначення приведе до збільшення об’єму пам’яті, а вибір функції - до
            збільшення часу роботи програми.
			</text>
			</sub_item>
			<sub_item>
				<item_title>  10.3. Включення файлу: #include</item_title>
				<text> 
            
            Коли препроцесор ”розпізнає” директиву #include , він шукає ім’я файлу і включає його в поточний файл. Вона
            може мати вигляд:
            #include &amp;amp;lt;stdio.h&amp;amp;gt; або ж
            #include “mystuff.h”
            В операційній системі UNIX дужки типу &amp;amp;lt; &amp;amp;gt; повідомляють препроцесору, що потрібний файл
            потрібно шукати в одному або декількох стандартних системних каталогах. А лапки ’’кажуть’’ , що спочатку
            потрібно дивитись в включеному каталозі, а потім потрібно шукати в “стандартних” місцях .
		</text>
		</sub_item>
		</sub_item>
        </content>
    </main>
    <tasks>
        <answers>
            11. Розв’язки вправ і завдань.

            11.1. Програми до розділу 1:
            1.1
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            { printf(&amp;amp;quot;Zhenya&amp;amp;quot;);}

            1.2.1.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            { printf(&amp;amp;quot;Lyosha\nKolokolchikovov\nKyiv\n&amp;amp;quot;);}

            1.2.2
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            #include&amp;amp;lt;conio.h&amp;amp;gt;
            main()
            {
            char name[20];
            char address[30];
            clrscr();
            printf(&amp;amp;quot;\n input name&amp;amp;quot;);
            printf(&amp;amp;quot;\nand then input address&amp;amp;quot;);
            scanf(&amp;amp;quot; %s &amp;amp;quot;,name);
            scanf(&amp;amp;quot;%s&amp;amp;quot;,address);
            printf(&amp;amp;quot;Your name is %s\n&amp;amp;quot;,name);
            printf(&amp;amp;quot;Your address is %s&amp;amp;quot;,address);
            getchar();
            }

            1.3.1.
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            void main()
            {
            int y1,m1,d1,y2,m2,d2,age,y,m,d;
            printf(&amp;amp;quot;input date(YEAR MONTH DAY)\n&amp;amp;quot;);
            scanf(&amp;amp;quot;%d %d %d&amp;amp;quot;,&amp;amp;y1,&amp;amp;m1,&amp;amp;d1); /*Вводимо через проміжок*/
            printf(&amp;amp;quot;input birthday date(YEAR MONTH DAY)\n&amp;amp;quot;);
            scanf(&amp;amp;quot;%d %d %d&amp;amp;quot;,&amp;amp;y2,&amp;amp;m2,&amp;amp;d2);
            if (d1&amp;amp;lt;d2) {m1--;d1+=30;}; /*Якшо «сьогодні» менше за день народження»*/
            if (m1&amp;amp;lt;m2) {y1--;m1+=12;}; /*Якшо «місяць сьогодні» менше за місяць */
            d=d1-d2; /* народження»*/
            m=m1-m2;
            y=y1-y2;
            printf(&amp;amp;quot;\nYou have lived %d years,%d month,%d days\n&amp;amp;quot;,y,m,d);
            }

            1.4.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #define Un 0.031 /*визначаємо константу - унцію*/
            #define cost_un 400.0 /*визначаємо константу - вартість унції*/
            main()
            {float your_weight;
            float cost;
            printf(&amp;amp;quot;\nInput your weight &amp;amp;quot;);
            scanf(&amp;amp;quot;\n%f&amp;amp;quot;,&amp;amp;your_weight);
            printf(&amp;amp;quot;\nWAIT: \n%3.3f&amp;amp;quot;,your_weight);
            cost=(your_weight/Un)*cost_un;
            printf(&amp;amp;quot;\nCost of gold is %f&amp;amp;quot;,cost);


            11.2. Програми до розділу 2:
            2.1
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #include &amp;amp;lt;values.h&amp;amp;gt;/*файл з визначеними константами*/
            main()
            {
            int a,a1,a2;
            float b,b1,b2;
            a=MAXINT; /*&amp;amp;quot;переповнюємо&amp;amp;quot;*/
            a1=MAXINT+1; /*&amp;amp;quot;переповнюємо&amp;amp;quot;*/
            a2=1/2;
            b=MAXFLOAT;
            b1=MAXFLOAT+1; /*&amp;amp;quot;переповнюємо&amp;amp;quot;*/
            b2=MAXFLOAT*10; /*&amp;amp;quot;переповнюємо&amp;amp;quot;*/
            printf(&amp;amp;quot;\n%d\t %d\t %d\t&amp;amp;quot;,a,a1,a2);
            printf(&amp;amp;quot;\n%e\t %e\t %e\t&amp;amp;quot;,b,b1,b2);
            }

            2.2
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            {int in,ch,fl,lon,shor,doubl,unsign;
            in=sizeof(int);
            ch=sizeof(char);
            fl=sizeof(float);
            lon=sizeof(long);
            shor=sizeof(short);
            doubl=sizeof(double);
            unsign=sizeof(unsigned);
            printf(&amp;amp;quot;\nCHAR %d&amp;amp;quot;,ch);
            printf(&amp;amp;quot;\nSHORT %d&amp;amp;quot;,shor);
            printf(&amp;amp;quot;\nINT %d&amp;amp;quot;,in);
            printf(&amp;amp;quot;\nLONG %d&amp;amp;quot;,lon);
            printf(&amp;amp;quot;\nFLOAT %d&amp;amp;quot;,fl);
            printf(&amp;amp;quot;\nDOUBLE %d&amp;amp;quot;,doubl);
            printf(&amp;amp;quot;\nUNSIGNED %d&amp;amp;quot;,unsign);
            }

            2.3.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            { char ch;
            printf(&amp;amp;quot;Input a char\n&amp;amp;quot;);
            scanf(&amp;amp;quot;%c&amp;amp;quot;,&amp;amp;ch);
            printf(&amp;amp;quot;Int of %c is %d\n&amp;amp;quot;,ch,ch);/*Виводимо символ як символ та як число(код)*/
            }


            2.4.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            {
            int a;
            double ah;
            scanf(&amp;amp;quot;%lf&amp;amp;quot;,ah);
            printf(&amp;amp;quot;Your double: %lf\n&amp;amp;quot;,ah);
            a=sizeof(double);
            printf(&amp;amp;quot;Bytes for double: %lf\n&amp;amp;quot;,a);
            }

            2.5.
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            #include&amp;amp;lt;string.h&amp;amp;gt;
            main()
            {char *surname=&amp;amp;quot;Bubenshchikov&amp;amp;quot;;
            printf(&amp;amp;quot;\nSize in memory for %s = %d&amp;amp;quot;,surname,sizeof(surname));
            printf(&amp;amp;quot;\nNumber of letters %d&amp;amp;quot;,strlen(surname));
            }


            2.6.1
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #define Y 10
            main()
            {
            int age;
            char name;
            printf(&amp;amp;quot;What is your name? &amp;amp;quot;);
            scanf(&amp;amp;quot;%s&amp;amp;quot;,name);
            printf(&amp;amp;quot;OK, %s, how old are you?\n&amp;amp;quot;,name);
            scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;age);
            int xp;
            xp=age+Y;
            printf(&amp;amp;quot; You must be %d.\n&amp;amp;quot;,xp);
            }

            2.6.2.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            {
            int age,den;
            printf(&amp;amp;quot;How old are you?\n&amp;amp;quot;);
            scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;age);
            den=age*365;
            printf(&amp;amp;quot;O-go-go!You have already lived %d days\n&amp;amp;quot;,den);
            }

            11.3. Програми до розділу 3:
            3.1.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            {
            int k[],i;
            for (i=1,k[1]=1; i&amp;amp;lt;=8*8; i++)
            {k[i]*=2;
            printf(&amp;amp;quot;place\tnum\tsum\t%&amp;amp;quot;); /*\t - табуляція*/
            printf(&amp;amp;quot;i=%d, i^2=%d\n&amp;amp;quot;,i,i*i);}
            }

            3.2.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #include &amp;amp;lt;math.h&amp;amp;gt;
            main(){
            double d,i,n=0;
            for(i=1;i&amp;amp;lt;=64;i++) {
            n+=pow(2,i-1);
            d= n/(7E14);
            printf(&amp;amp;quot;%2.0f. grains: %2.2E summa: %2.2E dolya: %2.2E\n&amp;amp;quot;,i,
            pow(2,i-1),n,d);
            }
            }

            3.3.
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            {
            unsigned int sec;
            int min;
            scanf(&amp;amp;quot;%ld&amp;amp;quot;,&amp;amp;sec);
            min=sec/60; /*ціла частина від ділення*/
            sec=sec%60; /*залишок від ділення*/
            printf(&amp;amp;quot;%d minut %d seconds&amp;amp;quot;,min,sec);
            }

            3. 4.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            {
            float i=1;
            float n;
            printf(&amp;amp;quot;\nAttention!The list of drobes&amp;amp;quot;);
            while(i++ &amp;amp;lt; 30)
            { n=(1.0/i); /* 1.0 тому що це має бути тип float*/
            printf(&amp;amp;quot;\n%f&amp;amp;quot;,n);
            }
            printf(&amp;amp;quot;\nThe end!&amp;amp;quot;);
            }

            3.5.1.
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            void main()
            {int i,count,sum,n;
            count=sum=0;
            scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;n); /*Це число n*/
            while(count++ &amp;amp;lt; n)
            sum+=count;
            printf(&amp;amp;quot;sum=%d\n&amp;amp;quot;,sum);
            }

            3.5.2.
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            void main()
            {int i,count,sum;
            count=sum=0;
            printf(&amp;amp;quot;and now input a number\n&amp;amp;quot;);
            scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;i);
            while (i) /*Поки і не дорівнює 0 робити*/
            {
            count=sum=0;
            while(count++ &amp;amp;lt; i)
            sum+=count;
            printf(&amp;amp;quot;sum of %d =%d\n&amp;amp;quot;,i,sum);
            printf(&amp;amp;quot;new value...\n&amp;amp;quot;);
            scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;i);}
            }

            3.6.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            main(){
            int i=0,ch;
            while((ch=getchar())!=EOF) /*Поки не кінець вхідного файлу*/
            if (ch==&amp;amp;apos;\n&amp;amp;apos;) i++; /*Лічимо зустрічання сиволу &amp;amp;quot;перехід рядку&amp;amp;quot;
            */
            printf(&amp;amp;quot;%d \n&amp;amp;quot;,i);
            }

            3.7.
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            {
            int i;
            char ch;
            printf(&amp;amp;quot;This program counts mainly &amp;amp;quot;&amp;amp;quot;full&amp;amp;quot;&amp;amp;quot;
            symbols (I hope)\n&amp;amp;quot;);
            printf(&amp;amp;quot;Exit is Ctrl-Z\n&amp;amp;quot;);
            while((ch=getchar())!=EOF)
            if ((ch!=&amp;amp;apos;\n&amp;amp;apos;)&amp;amp;&amp;amp;(ch!=&amp;amp;apos;\r&amp;amp;apos;)&amp;amp;&amp;amp;(ch!=&amp;amp;apos;\t&amp;amp;apos;)&amp;amp;&amp;amp;(ch!=&amp;amp;apos;\0&amp;amp;apos;)&amp;amp;&amp;amp;(ch!=&amp;amp;apos;\f&amp;amp;apos;)&amp;amp;&amp;amp;(ch!=&amp;amp;apos;
            &amp;amp;apos;)) i++;
            printf(&amp;amp;quot;Amount of symbols are %d&amp;amp;quot;,i);
            getchar();
            }

            3.8.1.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #include &amp;amp;lt;ctype.h&amp;amp;gt;
            main(){
            int i=0,ch;
            while((ch=getchar())!=EOF){
            if (isspace(ch)) i++;
            }
            printf(&amp;amp;quot;%d \n&amp;amp;quot;,i++);
            }

            3.8.2.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #include &amp;amp;lt;ctype.h&amp;amp;gt;
            main(){
            int i=0,k=0,ch;
            while((ch=getchar())!=EOF){
            if((ispunct(ch)||isspace(ch))&amp;amp;&amp;amp;(k==1))
            { k=0;i++; }
            if(!(ispunct(ch)||isspace(ch))){
            k=1;}
            }
            printf(&amp;amp;quot;%d \n&amp;amp;quot;,i);
            }

            3.9.
            main()
            { int weight, height;
            scanf(&amp;amp;quot;%d %d&amp;amp;quot;, &amp;amp;weight, &amp;amp;height);
            if (weight &amp;amp;lt; 100) {
            if (height &amp;amp;gt;= 72)
            printf(&amp;amp;quot;You are too high\n&amp;amp;quot;);
            else
            if (height &amp;amp;gt; 64)
            printf(&amp;amp;quot;You are high\n&amp;amp;quot;);};
            else
            if (weight &amp;amp;gt; 300 ){
            if (height&amp;amp;lt;48)
            printf(&amp;amp;quot;You are too small\n&amp;amp;quot;);};
            else
            printf(&amp;amp;quot;Ideal\n&amp;amp;quot;);
            }


            11.4. Програми до розділу 4:
            4.1.
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            void main()
            { int n,i,j;
            prinf(&amp;amp;quot;input n\n&amp;amp;quot;);
            scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;n);
            for (i=1 ;i&amp;amp;lt;=n;i++)
            {for(j=1;j&amp;amp;lt;=i;j++) prinf(&amp;amp;quot;$&amp;amp;quot;);
            prinf(&amp;amp;quot;\n&amp;amp;quot;);}
            }

            4.2.
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            {
            int i,from,to,rows;
            char what;
            void print(int,int,char,int);
            prinf(&amp;amp;quot;From,to,what,how many rows?\n&amp;amp;quot;);
            scanf(&amp;amp;quot;%d %d %c %d&amp;amp;quot;,&amp;amp;from,&amp;amp;to,&amp;amp;what,&amp;amp;rows);
            print(from,to,what,rows);
            scanf(&amp;amp;quot;\n&amp;amp;quot;);*/
            print(20,60,&amp;amp;apos;-&amp;amp;apos;,1);
            print(20,60,&amp;amp;apos;.&amp;amp;apos;,5);
            print(1,80,&amp;amp;apos;=&amp;amp;apos;,1);
            for(i=24;i&amp;amp;gt;=18;i--)
            print(i,60,&amp;amp;apos;|&amp;amp;apos;,1);
            print(24,60,&amp;amp;apos;|&amp;amp;apos;,5);
            print(24,60,&amp;amp;apos;/&amp;amp;apos;,1);
            print(30,58,&amp;amp;apos;|&amp;amp;apos;,2);
            scanf(&amp;amp;quot;\n&amp;amp;quot;);
            }

            void print(int from,int to,char what,int rows)
            { /*друкує необхідну кількість рядків заданого символу*/
            int i,j; /*між заданими позиціями у рядку*/
            for (j=1;j&amp;amp;lt;=rows;j++)
            {for (i=1;i&amp;amp;lt;=from;i++)
            prinf(&amp;amp;quot; &amp;amp;quot;);
            for (i=1;i&amp;amp;lt;=to-from;i++)
            prinf(&amp;amp;quot;%c&amp;amp;quot;,what);
            prinf(&amp;amp;quot;\n&amp;amp;quot;);
            }
            }

            4.4.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            {char ch;
            int Enter=0, Space=0, Tab=0, Num[10], i=0, j=0;
            while (j&amp;amp;lt;=9) Num[j++]=0;
            while ((ch=getchar())!=EOF)
            { j=ch-&amp;amp;apos;0&amp;amp;apos;; /*Переводимо &amp;amp;quot;символ-цифру&amp;amp;quot; у &amp;amp;quot;число-цифру&amp;amp;quot;,наприклад
            &amp;amp;apos;3&amp;amp;apos; у 3*/
            if ((j&amp;amp;gt;=0)&amp;amp;&amp;amp;(j&amp;amp;lt;=9)) Num[j]++; /*Рахуємо к-сті j-тої цифри у Num[j] */
            else (ch)
            { case &amp;amp;apos;\n&amp;amp;apos;: Enter++;break; /*Рахуємо рядки*/
            case &amp;amp;apos; &amp;amp;apos; : Space++;break; /*Проміжки*/
            case &amp;amp;apos;\t&amp;amp;apos;: Tab++;break; /*Символи табуляції*/
            default : i++;}}
            prinf (&amp;amp;quot;Number of \n Enter :%d \n Space :%d \n Tabs :%d \n&amp;amp;quot;,Enter,Space,Tab);
            j=-1;
            while (j++&amp;amp;lt;=9) if (Num[j]) prinf (&amp;amp;quot;Amount of numbers %d is %d\n&amp;amp;quot;,j,Num[j]);
            prinf (&amp;amp;quot;Amount of other symbols are %d&amp;amp;quot;,i);
            }

            4.5.
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            #include&amp;amp;lt;string.h&amp;amp;gt;
            void main()
            {
            int i,j,k,max;
            char p[25][80];
            i=0;
            while (gets(p[i])!=NULL) i++;
            max=strlen(p[0]);k=0;
            for(j=0;j&amp;amp;lt;=(i-1);j++)
            if ( strlen(p[j]) &amp;amp;gt; max ) /*Якщо знаходимо нову найдовший рядок - */
            { /*запамятовуємо його та його номер*/
            max=strlen(p[j]);
            k=j;
            }
            printf(&amp;amp;quot;In your file %d strings\n&amp;amp;quot;,i);
            printf(&amp;amp;quot;The longest is %d :\n&amp;amp;quot;,k+1);
            printf(&amp;amp;quot;The longest is %s\n&amp;amp;quot;,p[k]);
            }


            11.5. Програми до розділу 5:
            5.1.1.
            #define MAXLINE 128
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            char tabs[MAXLINE];
            settab()/*Початкове задання табуляції у масиві tabs (tabs[i]=1,якщо це - позиція табуляції
            0,8,16,... позиції*/
            { int i;
            for (i=0;i&amp;amp;lt;MAXLINE;i++)
            tabs[i]=(i%8?0:1);
            }
            tabpos(int col) /*Перевірка чи є col позицією табуляції*/
            { return col&amp;amp;lt;MAXLINE?tabs[col]:1;}

            main()
            {int c,col;
            settab();
            col=0;
            while((c=getchar())!=EOF)
            if(c==&amp;amp;apos;\t&amp;amp;apos;) /*Якщо зустрівся символ табуляції*/
            do putchar(&amp;amp;apos; &amp;amp;apos;);while(!tabpos(++col)); /*Виводимо пропуски до наступної */
            /*позиції табуляції*/
            else{putchar(c);
            col=(c==&amp;amp;apos;\n&amp;amp;apos;?0:col+1);}
            }

            5.2.
            #define MAXLINE 128
            char tabs[MAXLINE];
            settab()/*Початкове задання табуляції у масиві tabs (tabs[i]=1,якщо це - позиція
            табуляції 0,8,16,... позиції*/
            { int i;
            for (i=0;i&amp;amp;lt;MAXLINE;i++)
            tabs[i]=(i%8?0:1);
            }
            tabpos(int col) /*Перевірка чи є col позицією табуляції*/
            { return col&amp;amp;lt;MAXLINE?tabs[col]:1;}
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            { int c,
            col,/*Позиція виведення наступного символу*/
            ncol; /*Позиція символу введення */
            settab(); col=0;
            for(;;)
            { ncol=col;
            while ((c=getchar())==&amp;amp;apos; &amp;amp;apos;)
            { ncol++;
            if(tabpos(ncol)) /*Якщо в позиції табуляції*/
            { putchar(&amp;amp;apos;\t&amp;amp;apos;);col=ncol;}
            }
            for(;col&amp;amp;lt;ncol;col++) putchar(&amp;amp;apos; &amp;amp;apos;); /*Якщо залишились проміжки*/
            if(c==EOF) break;
            putchar(c);
            col=(c==&amp;amp;apos;\n&amp;amp;apos;)?0:col+1;
            }
            }


            5.3.1
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            #include&amp;amp;lt;string.h&amp;amp;gt;
            #include&amp;amp;lt;math.h&amp;amp;gt;
            main()
            {
            long int htoi(char *);
            char s1[255],ch;
            printf(&amp;amp;quot;input hex-number\n&amp;amp;quot;);
            gets(s1);
            printf(&amp;amp;quot;%ld&amp;amp;quot;,htoi(s1));
            }

            long int htoi(char *s1)
            {long int p,i, s=0;
            for (i=0;i&amp;amp;lt;=strlen(s1)-1;i++)
            { p=pow(16,strlen(s1)-1-i); /*За правилом &amp;amp;apos;AB8&amp;amp;apos;=A*16^2+B*16^1+8*16^0 */
            if((s1[i]&amp;amp;gt;=&amp;amp;apos;0&amp;amp;apos;)&amp;amp;&amp;amp;(s1[i]&amp;amp;lt;=&amp;amp;apos;9&amp;amp;apos;))
            s+=(s1[i]-&amp;amp;apos;0&amp;amp;apos;)*p ;else/*Переводимо символ &amp;amp;apos;0&amp;amp;apos; у
            число 0, і так для всіх цифр*/
            if((s1[i]&amp;amp;gt;=&amp;amp;apos;A&amp;amp;apos;)&amp;amp;&amp;amp;(s1[i]&amp;amp;lt;=&amp;amp;apos;F&amp;amp;apos;))
            s+= (s1[i]-55)*p ;else /*так само за правилом
            великі літери*/
            if((s1[i]&amp;amp;gt;=&amp;amp;apos;a&amp;amp;apos;)&amp;amp;&amp;amp;(s1[i]&amp;amp;lt;=&amp;amp;apos;f&amp;amp;apos;))
            s+= (s1[i]-87)*p;else /*... і маленькі*/
            {printf(&amp;amp;quot;error!!!!!!!!!!!!!!!!!!!!!!&amp;amp;quot;);s=-1;break;}; /*якщо не цифра та не &amp;amp;apos;A&amp;amp;apos;..&amp;amp;apos;f&amp;amp;apos;
            - помилка */
            }
            return s;
            }

            5.4.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            char *strcat(char *s,char *t)
            {int i=0,j=0;
            char * d=s; /*Показник d вказує тепер те місце пам&amp;amp;apos;яті що і s */
            while(*s++); /*Йдемо по s до символу &amp;amp;apos;\0&amp;amp;apos;*/
            *s--; /*Крок назад (щоб уникнути символу &amp;amp;apos;\0&amp;amp;apos;) */
            while((*s++=*t++));/*А тепер дописуємо рядок t до s (В кінці - символ &amp;amp;apos;\0&amp;amp;apos;)*/
            return(d); /* Повертаємо d (він вказує на початок отриманого рядка)*/
            }
            main()
            {char c[255],r[255];
            prinf(&amp;amp;quot;enter1 :&amp;amp;quot;);
            scanf(&amp;amp;quot;%s&amp;amp;quot;,&amp;amp;c);
            prinf(&amp;amp;quot;enter2 :&amp;amp;quot;);
            scanf(&amp;amp;quot;%s&amp;amp;quot;,&amp;amp;r);
            prinf(&amp;amp;quot;%s&amp;amp;quot;,strcat(c,r));
            }


            5.5.
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            any(char *s1,char *s2)
            {int flag;
            int i=0,j=0;
            for(i=0;i&amp;amp;lt;=strlen(s1);i++)/*Цикл поки не знайдемо позицію */
            { flag=0; /*i коли s1[i]== s2[0] */
            if(s1[i]==s2[0])
            { for(j=0;j&amp;amp;lt;=strlen(s2)-1;j++) /*А тепер перевіряємо чи саме з i-тої поз-ції*/
            if(s1[i+j]!=s2[j]) flag=1; /* починається підрядок s2*/
            if (!flag) return(i+1); } /*Якщо підрядки співпадають - повернути i*/
            }
            return (-1); /*Якщо ні - повернути -1*/
            }

            main()
            {char s[80], d[80];
            scanf(&amp;amp;quot;%s %s&amp;amp;quot;,&amp;amp;s,&amp;amp;d);
            prinf(&amp;amp;quot;\n %d&amp;amp;quot;,any(s,d));}

            5.6.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            getbits(unsigned x, unsigned p, unsigned n)
            { return ((x&amp;amp;gt;&amp;amp;gt;(p+1-n)) &amp;amp; ~(~0&amp;amp;lt;&amp;amp;lt;n));
            }
            void main(void) {
            prinf(&amp;amp;quot;%d\n&amp;amp;quot;, getbits(2, 2, 3));
            }


            5.6.а.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            getbits(unsigned x, unsigned p, unsigned n) {
            return ((x&amp;amp;lt;&amp;amp;lt;(p+1-n)) &amp;amp; ~(~0&amp;amp;lt;&amp;amp;lt;n));
            }
            void main(void) {
            prinf(&amp;amp;quot;%d\n&amp;amp;quot;, getbits(0xFF, 2, 3));
            }

            5.6.б.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            int wordlength(void) {
            unsigned int data=~0, n=0;
            while (((~0)/(unsigned)2+1) &amp;amp; data) {
            data &amp;amp;lt;&amp;amp;lt;= 1;
            n++;
            }
            return n;
            }
            void main(void) {
            prinf(&amp;amp;quot;This compiler has %d bits per int\n&amp;amp;quot;, wordlength());
            }


            5.6.в.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            unsigned rightrot(unsigned n, unsigned b) {
            int i, o;
            for (i=1; i&amp;amp;lt;=b; i++) {
            o=n &amp;amp; 1;
            n=(n&amp;amp;gt;&amp;amp;gt;1) | (o&amp;amp;lt;&amp;amp;lt;15);
            }
            return n;
            }
            unsigned leftrot(unsigned n, unsigned b) {
            int i, o;
            for (i=1; i&amp;amp;lt;=b; i++) {
            o=(n &amp;amp; ((~0)/(unsigned)2+1)) &amp;amp;gt;&amp;amp;gt; 15;
            n=(n&amp;amp;lt;&amp;amp;lt;1) | o;
            }
            return n;
            }
            void main(void) {
            prinf(&amp;amp;quot;%u\n&amp;amp;quot;, rightrot(2, 1));
            }

            5.6.г.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            invert(unsigned int x,unsigned int p,unsigned int n)
            {unsigned int a,b,c;
            a=((~0)&amp;amp;lt;&amp;amp;lt;(p-1));
            a^=(~0&amp;amp;lt;&amp;amp;lt;(p+n-1));
            b=~a;
            return((~(x&amp;amp;a)&amp;amp;a)|(x&amp;amp;b));
            }
            main()
            {
            unsigned int x,p,n;
            scanf(&amp;amp;quot;%u&amp;amp;quot;,&amp;amp;x);
            scanf(&amp;amp;quot;%u&amp;amp;quot;,&amp;amp;p);
            scanf(&amp;amp;quot;%u&amp;amp;quot;,&amp;amp;n);
            prinf(&amp;amp;quot;my %u&amp;amp;quot;,invert(x,p,n));
            }


            11.6. Програми до розділу 6:
            6.1.1
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            int i, str[80] /* Запам&amp;amp;apos;ятовуємо наш вхідний рядок у масиві*/;

            main()
            {int numb(int);
            char ch; float res=0.0,stack[50]; int j=0,x,er=0;
            printf(&amp;amp;quot;Input number §\n&amp;amp;quot;);

            for (i=0;ch!=&amp;amp;apos;\n&amp;amp;apos;;i++)
            { ch=getchar();
            str[i]=ch;
            }
            for (i=0;str[i]!=&amp;amp;apos;\n&amp;amp;apos;;i++) /*Поки не кінець рядка*/
            {
            if ((str[i]&amp;amp;gt;=48)&amp;amp;&amp;amp;(str[i]&amp;amp;lt;=57))
            {x=str[i]-48; stack[j++]=numb(x);} /*Якщо число - у стек заносимо*/
            else /*інакше*/
            switch(str[i]) /*Якщо операція - виймаємо зі стеку 2 числа , обчислюємо,
            результат заносимо у стек */
            {case &amp;amp;apos;+&amp;amp;apos;:res=stack[j-1]+stack[j-2];j-=1;stack[j-1]=res;break;
            case &amp;amp;apos;-&amp;amp;apos;:res=stack[j-1]-stack[j-2];j-=1;stack[j-1]=res;break;
            case &amp;amp;apos;*&amp;amp;apos;:res=stack[j-1]*stack[j-2];j-=1;stack[j-1]=res;break;
            case &amp;amp;apos;/&amp;amp;apos;:if (!stack[j-2]) {er=1;break;}res=stack[j-1]/stack[j-2];j-
            =1;stack[j-1]=res; break;
            case &amp;amp;apos; &amp;amp;apos;:break;
            default:er=1; /*Якщо не число та не операція - помилка*/
            }
            }
            if (er) printf(&amp;amp;quot;Error!!!!!!!!!!!!!!!!!!!!!!&amp;amp;quot;);
            else printf(&amp;amp;quot;%5f&amp;amp;quot;,res);
            }

            int numb(int y) /*Функція перетворює рядок у число ,наприклад &amp;amp;apos;3243&amp;amp;apos; у 3243 */
            {
            while ((str[i+1]-48)&amp;amp;gt;=0 &amp;amp;&amp;amp; (str[i+1]-48)&amp;amp;lt;=9)
            {y=y*10+(str[i+1]-48);i++;
            }
            return((float)y);
            }

            6.2.а.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            void main()
            {
            char * int2str(long int n);
            long int n;
            puts(&amp;amp;quot;input n&amp;amp;quot;); scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;n) ; /*Вводимо
            число */
            puts(int2str(n)); /*Повертаємо рядок*/
            }

            int mas[20], i=0;
            char* int2str(long int n)
            { void lint2str(long int );
            int m=0 ;
            char ma[255]=&amp;amp;quot;&amp;amp;quot;; /*Результат*/
            lint2str(n); /*Переводимо*/
            for (m=0;m&amp;amp;lt;i;m++)
            ma[i-1-m]=(char)(mas[m]+48); /*Перекидаємо цифри з mas[] у символи ma[] */
            return ma; /*Повертаємо результат*/
            }
            void lint2str(long int n) /*recursive function...*/
            { if (n!=0)
            {mas[i++]=n%10; /*Запам&amp;amp;apos;ятовуємо останню цифру числа */
            n/=10; /*Відкидаємо її */
            lint2str(n); /*Рекурсія*/
            }}
            6.2.б.
            #include &amp;amp;lt;string.h&amp;amp;gt;
            #include &amp;amp;lt;math.h&amp;amp;gt;
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            void main()
            { char *s; int str2int(char *);
            puts(&amp;amp;quot;You are to input number-string and I&amp;amp;apos;ll make it integer..&amp;amp;quot;);
            gets(s);puts(&amp;amp;quot;-it was string&amp;amp;quot;);
            printf(&amp;amp;quot;%d -and it&amp;amp;apos;s integer&amp;amp;quot;,str2int(s));

            }
            int i=0,f=0;
            int str2int(char s[255]) /*recursive function...*/
            { int l=(strlen(s)-1);
            if (i==l+1) return f;
            f+=(s[i]-48)*pow(10,l-i); /*За формулою &amp;amp;apos;234&amp;amp;apos;=2*10^2+3*10^1+4*10^0 */
            i++;
            str2int(s); /*Рекурсія*/
            }

            6.3.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            void main()
            {
            double power(double,int);
            double x;int y;
            puts(&amp;amp;quot;input x,y &amp;amp;quot;);
            scanf(&amp;amp;quot;%lf %d&amp;amp;quot;,&amp;amp;x,&amp;amp;y);
            printf(&amp;amp;quot;x in y = %.3lf&amp;amp;quot;,power(x,y));
            }
            double power(double x,int y)
            { switch(y)
            {
            case 0:return 1;
            case 1:return x;
            }
            return ((y&amp;amp;gt;0)? (x*power(x,y-1)): (1/(x*power(x,y-1))));
            }

            6.4.
            file power.c
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            #include&amp;amp;quot;pow.c&amp;amp;quot;
            void main()
            {
            double x;
            int y;
            double power(double,int);
            printf(&amp;amp;quot;input x ,y \n&amp;amp;quot;);
            scanf(&amp;amp;quot;%lf %d&amp;amp;quot;,&amp;amp;x,&amp;amp;y);
            printf(&amp;amp;quot; = %5.3g&amp;amp;quot;,power(x,y));
            }
            file pow.c
            double power(double x,int y)
            {
            int i;
            double s=1.0;
            if (y==0.0) return (s);
            else
            if (y&amp;amp;gt;0.0) for (i=1;i&amp;amp;lt;=y;i++) s*=x;
            else for (i=1;i&amp;amp;lt;=(-y);i++) s/=x;
            return (s);
            }

            6.5.
            #include&amp;amp;lt;stdiio.h&amp;amp;gt;
            void main()
            {
            int m;long int n;
            int sum_digits(int,int);
            puts(&amp;amp;quot;Введіть n &amp;amp;quot;); scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;n) ;
            puts( &amp;amp;quot;Введіть m, сума цифр чисел &amp;amp;lt; n повинна дорів-ти m &amp;amp;quot;);scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;m)
            ;
            sum_digits(n,m);
            }

            int sum_digits(int n,int m) /*Повертає кількість таких чисел...*/
            {int s,mas[100],k=0;int temp;
            for (int j=1;j&amp;amp;lt;n;j++)
            {
            s=0;temp=j;
            while (temp!=0)
            {s+=temp%10; /*Сумма цифр j-того числа*/
            temp/=10;}; /*У змінній s - сума цифр*/
            if(s==m) { mas[++k]=j;
            puts(&amp;amp;quot;Yes&amp;amp;quot;);
            };
            };
            for ( int i=1;i&amp;amp;lt;k+1;i++) printf(&amp;amp;quot;%d &amp;amp;quot;,mas[i]);
            printf(&amp;amp;quot;\nThere are %d such numbers!..&amp;amp;quot;,k);
            return k;
            }

            6.6.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            void main()
            {
            int funct(float);
            float n;
            puts(&amp;amp;quot;Введіть n , n=666 - кінець&amp;amp;quot;);
            scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;n);
            while (n!=666)
            { funct(n);
            puts(&amp;amp;quot;\n\nВведіть n , n=666 -кінець\n&amp;amp;quot;);
            scanf(&amp;amp;quot;d&amp;amp;quot;,&amp;amp;n);
            };
            }

            int funct(float n)
            { int sim(int );
            static int k=0;
            if (n&amp;amp;lt;=0) {k++;printf(&amp;amp;quot;%d- звернення, (ви ввели n&amp;amp;lt;=0)&amp;amp;quot;,k);return
            k;};
            if (n&amp;amp;gt;0){printf(&amp;amp;quot;\n %d-е просте число = : &amp;amp;quot;,n);
            return sim(n);
            };
            }
            int sim(int n)
            {int s[1000] /*Будемо зберігати знайдені прості числа*/,
            k=0, flag;
            for (int i=1;k!=n;i++)
            { flag=1;
            for (int j=2;j&amp;amp;lt;=i-1;j++)
            if ((i%j)==0) flag=0; /*Якщо не просте - воно нам не потрібне*/
            if (flag==1) s[++k]=i; /*Інакше - запам&amp;amp;apos;ятаємо*/
            };
            printf(&amp;amp;quot;%d&amp;amp;quot;,s[n]);
            return s[n]; /*А повернемо n-е просте число*/
            }

            6.7.1
            #include &amp;amp;lt;stdlib.h&amp;amp;gt;
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #include &amp;amp;lt;math.h&amp;amp;gt;
            #include &amp;amp;lt;string.h&amp;amp;gt;
            float getfloat(void)
            { int k=0,/*Число до крапки*/
            pos=0,
            k2=0, /*Число після крапки*/
            k3=0; /*Число після E */
            char ch;
            char str[20];
            printf(&amp;amp;quot;Input string and then Ctrl Z\n&amp;amp;quot;);
            while((ch=getchar()) != EOF)
            {
            if ((ch&amp;amp;gt;=48)&amp;amp;&amp;amp;(ch&amp;amp;lt;=57))
            if (pos==1) k2=k2*10+(ch-&amp;amp;apos;0&amp;amp;apos;);
            else if(pos==0) k=k*10+(ch-&amp;amp;apos;0&amp;amp;apos;);
            else k3=k3*10+(ch-&amp;amp;apos;0&amp;amp;apos;); /*pos==2*/
            if (ch==&amp;amp;apos;.&amp;amp;apos;) pos=1;
            if (ch==&amp;amp;apos;e&amp;amp;apos; || ch==&amp;amp;apos;E&amp;amp;apos;) pos=2;
            }
            return ((float)k+(float)k2/pow(10, (float)strlen(itoa(k2, str, 10))))*pow(10, k3);
            }

            void main(void)
            { printf(&amp;amp;quot;%e\n&amp;amp;quot;, getfloat());
            }

            6.7.2
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #include &amp;amp;lt;ctype.h&amp;amp;gt;
            void get_float(char*);
            void main()
            { char *str=&amp;amp;quot;o89e6jie_ehf&amp;amp;quot;;
            get_float(str);
            }
            void get_float(char *str)
            { int i,ch;
            float num=0;
            while(*str) /*Поки не кінець вхідної стрічки*/
            { if(isdigit(ch=*str)) /*Якщо цифра*/
            { while(isdigit(ch=*str++)) num=num*10+ch-48; /*Запм&amp;amp;apos;ятовуємо число до &amp;amp;apos;.&amp;amp;apos;
            */
            if(ch==&amp;amp;apos;.&amp;amp;apos;)
            { if(isdigit(ch=*str))
            { i=10;
            while(isdigit(ch))
            { num+=(float)(ch-48)/i; i*=10; ch=*++str;} /*Тепер число до E*/
            printf(&amp;amp;quot;%f\n&amp;amp;quot;,num);
            }
            }
            else if(ch==&amp;amp;apos;e&amp;amp;apos;||ch==&amp;amp;apos;E&amp;amp;apos;)
            if(isdigit(ch=*str++))
            { while(isdigit(ch=*str++)) for(i=0;i&amp;amp;lt;ch;i++,num*=10); /*А тепер усе число*/
            printf(&amp;amp;quot;%e\n&amp;amp;quot;,num);
            }
            } num=0; str++;
            }
            }


            11.7. Програми до розділу 7:
            7.1.а.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            void main()
            { int *a, *b,n,sc,scal(int*,int*,int);
            printf(&amp;amp;quot;input n\n&amp;amp;quot;);
            scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;n);
            for (int i=0;i&amp;amp;lt;n;i++)
            scanf(&amp;amp;quot;%d&amp;amp;quot;,(a+i));
            for ( i=0;i&amp;amp;lt;n;i++)
            scanf(&amp;amp;quot;%d&amp;amp;quot;,(b+i));
            sc=scal(a,b,n);
            printf(&amp;amp;quot;%d\n&amp;amp;quot;, sc);
            }

            int scal(int *a, int *b,int n)
            { int i, k=0;
            for (i=1; i&amp;amp;lt;=n; i++)
            { k += *a++ * *b++;
            }
            return k;
            }

            7.1.б.
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            {int sort(int *,int),n,temp,a[100],i;
            puts(&amp;amp;quot;input n&amp;amp;quot;);
            scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;n);
            for(i=1;i&amp;amp;lt;=n;i++)
            {printf(&amp;amp;quot;input %d element\n&amp;amp;quot;,i);
            scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;temp);a[i]=temp;};
            printf(&amp;amp;quot; &amp;amp;d retransmissions &amp;amp;quot;, sort(a,n));
            }
            int sort(int *a,int n)
            {int is,i,c,s=0;
            do {is=0;
            for(i=1;i&amp;amp;lt;n;i++)
            if(a[i] &amp;amp;gt; a[i+1])
            {c=a[i+1];a[i+1]=a[i];a[i]=c;is=1;s++;}
            }
            while(is);
            for(i=1;i&amp;amp;lt;=n;i++)
            printf(&amp;amp;quot;%d &amp;amp;quot;,a[i]);
            return s;
            }

            7.1.в.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #include &amp;amp;lt;string.h&amp;amp;gt;
            int compar(char *sub, char *mai) /*Перевіряє чи рівні рядок sub та така ж за */
            /*довжиною частина рядка mai*/
            { while (*sub)
            if (*sub++!=*mai++) return(0);
            return(1);}

            main()
            {int i,j,k; char *mai,*sub;
            printf(&amp;amp;quot;Enter the main string: &amp;amp;quot;);gets(mai);
            printf(&amp;amp;quot;Enter the sub string: &amp;amp;quot;);gets(sub);
            i=strlen(sub);k=strlen(mai); k-=i;i=0;
            for (j=0;j&amp;amp;lt;=k;j++)
            if (compar(sub,mai++))
            {printf(&amp;amp;quot;Підрядок починається після %d символу\n&amp;amp;quot;,j);i=1;break;}
            if (i==0) printf(&amp;amp;quot;Oppa!&amp;amp;quot;);
            }

            7.1.г.
            #include&amp;amp;lt;string.h&amp;amp;gt;
            #include&amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            {
            char *s1,*s2;
            int l(char *,char *);
            printf(&amp;amp;quot;Введiть два pядки\n&amp;amp;quot;);
            gets(s1);
            gets(s2);
            printf(&amp;amp;quot;\nHайбiльша довжина спiльної послiдовностi
            символiв pядiв доpiвнює %d&amp;amp;quot;,l(s1,s2));
            }
            int l(char *s1,char *s2)
            {
            int i,j,k=0,l=0;
            for(i=0;i&amp;amp;lt;=strlen(s1);i++)
            for(j=l; j&amp;amp;lt;=strlen(s2);j++)
            if(s1[i]==s2[j]) {k++; l=j+1;}
            return --k;
            }

            7.2.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            main()
            {int n;char *month(int);
            puts(&amp;amp;quot;Введiть n&amp;amp;quot;);
            scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;n);
            puts(month(n));
            }
            char * month(int n)
            {char*mas[13]={&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;January&amp;amp;quot;,&amp;amp;quot;February&amp;amp;quot;,&amp;amp;quot;March&amp;amp;quot;,&amp;amp;quot;April&amp;amp;quot;,&amp;amp;quot;May&amp;amp;quot;,&amp;amp;quot;June&amp;amp;quot;,&amp;amp;quot;July&amp;amp;quot;,
            &amp;amp;quot;August&amp;amp;quot;,&amp;amp;quot;September&amp;amp;quot;,&amp;amp;quot;October&amp;amp;quot;,&amp;amp;quot;November&amp;amp;quot;,&amp;amp;quot;December&amp;amp;quot;};
            return(mas[n]);
            }

            7.3.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #include &amp;amp;lt;string.h&amp;amp;gt;
            extern int i=0;
            /*а)*/
            void printar(char pch[1000],int j)
            {int k;
            for (k=0;k&amp;amp;lt;j;k++)
            if (pch[k])
            {putchar(pch[k]); if (pch[k+1]==&amp;amp;apos;\0&amp;amp;apos;) putchar(&amp;amp;apos;\n&amp;amp;apos;);}
            }
            /*б)*/
            void compare (char pch[1000],char *p) /*Знаходимо рядок*/
            {extern int i;int k;
            for (k=0;k&amp;amp;lt;i;k++)
            if (pch[k])
            if(!strcmp(p,&amp;amp;pch[k]))
            {printf(&amp;amp;quot;\nString exist!\n&amp;amp;quot;);return;}
            else while (pch[k]) k++;
            while ((*p) &amp;amp;&amp;amp; (i&amp;amp;lt;1000)) pch[i++]=*p++;
            if (i&amp;amp;gt;=1000) printf (&amp;amp;quot;\nArray overflow\n&amp;amp;quot;);
            }
            /*в)*/
            void delet (char pch[1000],char *p) /*Видаляємо слово з масиву*/
            {extern int i;int k;
            for (k=0;k&amp;amp;lt;i;k++)
            if (pch[k])
            if(strcmp(p,&amp;amp;pch[k])==0)
            {printf(&amp;amp;quot;\nString exist!\n&amp;amp;quot;);
            while (pch[k]) {pch[k]=0;k++;}return;}
            else while (pch[k]) k++;
            }
            /*г)*/
            void compr(char *ch, int k) /*Ущільнюємо масив*/
            {extern i;
            char *p; int j,l=0;
            for (j=0;j&amp;amp;lt;k;j++)
            if(*ch) {*p++=*ch++;l++;}
            else {*p++=&amp;amp;apos;\0&amp;amp;apos;;
            l++;
            while (*ch==&amp;amp;apos;\0&amp;amp;apos;) {*ch++;j++;} }
            for (j=0;j&amp;amp;lt;l;j++) *ch++=*p++;
            i=l;
            printf (&amp;amp;quot;\nDeleted %d 0-symbols\n&amp;amp;quot;,k-l);
            }

            main()
            {char ch[1000],c,*p;
            extern int i;clrscr();
            printf(&amp;amp;quot;Enter 1000-symbol string (Enter = 0-symbol; Ctrl-Z = EOL)\n&amp;amp;quot;);
            while ((c=getchar())!=EOF)
            {if ((c&amp;amp;gt;&amp;amp;apos; &amp;amp;apos;) &amp;amp;&amp;amp; (c&amp;amp;lt;=&amp;amp;apos;z&amp;amp;apos;))
            ch[i++]=c; else if (c==&amp;amp;apos;\n&amp;amp;apos;) ch[i++]=&amp;amp;apos;\0&amp;amp;apos;;}
            printar(ch,i);
            printf(&amp;amp;quot;\nEnter the string, which will be compared with array\n&amp;amp;quot;);
            gets(p);
            compare (ch,p);
            printar (ch,i);
            printf(&amp;amp;quot;\nEnter the string, which will be deleted from array\n&amp;amp;quot;);
            gets(p);
            delet(ch,p);
            printar(ch,i);
            compr(ch,i);
            }

            7.4.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #include &amp;amp;lt;string.h&amp;amp;gt;
            #include &amp;amp;lt;alloc.h&amp;amp;gt;
            void unmess(char **p) /*Впорядковує покажчики*/
            {char *p1;int flag,j;
            do {flag=0; for (j=0;j&amp;amp;lt;100;j++)
            if (strcmp(*(p+j),*(p+j+1))&amp;amp;gt;0) /*Лексикографічно порівнюємо рядки*/
            { p1=*(p+j);*(p+j)=*(p+j+1);*(p+j+1)=p1;
            flag=1;}}
            while (flag);
            }

            main()
            {char *p[100],*p1[100];
            int i;
            for (i=0;i&amp;amp;lt;100;i++)
            {p[i]=(char*)calloc(40,sizeof(char));
            }
            printf(&amp;amp;quot;Enter 100-string array \n&amp;amp;quot;);
            for (i=0;i&amp;amp;lt;100;i++)
            {printf(&amp;amp;quot;Enter %d -string :&amp;amp;quot;,i+1);gets(p[i]);p1[i]=p[i];}
            unmess(p);
            for (i=0;i&amp;amp;lt;100;i++) puts(p[i]);
            }


            7.5.а.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #include &amp;amp;lt;math.h&amp;amp;gt;
            double a,b,c;
            void main()
            {
            void inf_tri();
            puts(&amp;amp;quot;input a,b,c &amp;amp;quot;);
            scanf(&amp;amp;quot;%lf %lf %lf&amp;amp;quot; &amp;amp;a,&amp;amp;b,&amp;amp;c;
            puts(&amp;amp;quot;info about triangle : &amp;amp;quot;);
            inf_tri();
            }
            void inf_tri()
            { double P,p,s;
            p=(P=a+b+c)/2; s=sqrt(p*(p-a)*(p-b)*(p-c)); /*Формула Герона*/
            printf(&amp;amp;quot;Perimetr=%lf Square=%lf&amp;amp;quot;,P,s);
            }


            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #include &amp;amp;lt;math.h&amp;amp;gt;
            void main()
            {
            void inf_tri(double*,double*,double*);
            double a,b,c;
            puts(&amp;amp;quot;input a,b,c &amp;amp;quot;);
            scanf(&amp;amp;quot;%lf %lf %lf&amp;amp;quot; &amp;amp;a,&amp;amp;b,&amp;amp;c;
            puts(&amp;amp;quot;info about triangle : &amp;amp;quot;);
            inf_tri(&amp;amp;a,&amp;amp;b,&amp;amp;c);
            }
            void inf_tri(double *a,double *b,double *c)
            { double P,p,s;
            p=(P=*a+*b+*c)/2; s=sqrt(p*(p-*a)*(p-*b)*(p-*c)); /*Формула Герона*/
            printf(&amp;amp;quot;Perimetr=%lf Square=%lf&amp;amp;quot;,P,s);
            }

            7.6.б.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            void main()
            {
            int n,find_ab(int *);
            puts(&amp;amp;quot;input n , n &amp;amp;gt; 7 &amp;amp;quot;);
            scanf( &amp;amp;quot; %d&amp;amp;quot;,&amp;amp;n);
            find_ab(&amp;amp;n);
            }
            void find_ab(int *n)
            {int mas[30][2],a,b,i,k=0,co=1;
            for (a=1;a&amp;amp;lt;*n+1;a++)
            for (b=1;b&amp;amp;lt;=*n+1;b++)
            {if ((5*a+3*b)==*n) /*Шукаємо коли 5*а+3*b=n*/
            {co=0;
            mas[++k][1]=a;
            mas[k][2]=b;
            printf(&amp;amp;quot; a= %d b= %d&amp;amp;quot;,a,b);
            };
            };
            if(co) puts(&amp;amp;quot; no answer !!!!!!!!!!!&amp;amp;quot;);

            int min,j;
            min=mas[1][1]+mas[1][2];j=1;
            for(i=1;i&amp;amp;lt;=k;i++)
            if (mas[i][1]+mas[i][2]&amp;amp;lt;min) { min=mas[i][1]+mas[i][2]; /*Вибираємо min з (a+b)*/
            j=i;};
            puts(&amp;amp;quot;The sum is min when ,when&amp;amp;quot;);
            printf( &amp;amp;quot;a= %d b=%b&amp;amp;quot;,mas[j][1],mas[j][2]);
            }

            7.7.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            int n;
            void main()
            {
            int find_ab();
            puts(&amp;amp;quot;input n , n &amp;amp;gt; 7 &amp;amp;quot;);
            scanf( &amp;amp;quot; %d&amp;amp;quot;,&amp;amp;n);
            find_ab();}
            void find_ab()
            {int mas[30][2],a,b,i,k=0;
            for (a=1;a&amp;amp;lt;n+1;a++)
            for (b=1;b&amp;amp;lt;=n+1;b++)
            {if ((5*a+3*b)==n)
            {
            mas[++k][1]=a;
            mas[k][2]=b;
            printf(&amp;amp;quot; a= %d b= %d&amp;amp;quot;,a,b);
            };
            };
            int min,j;
            min=mas[1][1]+mas[1][2];
            for(i=1;i&amp;amp;lt;=k;i++)
            if (mas[i][1]+mas[i][2]&amp;amp;lt;min) { min=mas[i][1]+mas[i][2]; j=i;};
            puts(&amp;amp;quot;The sum is min when ,when&amp;amp;quot;);
            printf( &amp;amp;quot;a= %d b=%b&amp;amp;quot;,mas[j][1],mas[j][2]); }

            Вправи і завдання до розділу 8:
            8.1.
            main()
            {char *s1,*s2,*strcat(char*,char *);
            puts(&amp;amp;quot;Введіть s1&amp;amp;quot;);
            gets(s1);
            puts(&amp;amp;quot;Введіть s2&amp;amp;quot;);
            gets(s2);
            puts(strcat(s1,s2));
            }

            char *strcat(char *s,char *t)
            { char * d=s; /*Показник d вказує тепер те місце пам&amp;amp;apos;яті що і s */
            while(*s++); /*Йдемо по s до символу &amp;amp;apos;\0&amp;amp;apos;*/
            *s--; /*Крок назад (щоб уникнути символу &amp;amp;apos;\0&amp;amp;apos;) */
            while((*s++=*t++));/*А тепер дописуємо рядок t до s (В кінці - символ &amp;amp;apos;\0&amp;amp;apos;)*/
            return(d); /* Повертаємо d (він вказує на початок отриманого рядка)*/
            }

            8.2.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #include &amp;amp;lt;string.h&amp;amp;gt;
            #include &amp;amp;lt;stdlib.h&amp;amp;gt;
            char str[55]=&amp;amp;quot;&amp;amp;quot;;
            char *day_of_year(int d, int m, int y) {
            char *month[12]={&amp;amp;quot;january&amp;amp;quot;, &amp;amp;quot;febryary&amp;amp;quot;, &amp;amp;quot;march&amp;amp;quot;,
            &amp;amp;quot;april&amp;amp;quot;, &amp;amp;quot;may&amp;amp;quot;, &amp;amp;quot;june&amp;amp;quot;,
            &amp;amp;quot;july&amp;amp;quot;, &amp;amp;quot;august&amp;amp;quot;, &amp;amp;quot;september&amp;amp;quot;,
            &amp;amp;quot;october&amp;amp;quot;, &amp;amp;quot;novemner&amp;amp;quot;, &amp;amp;quot;december&amp;amp;quot;};
            char str2[4];
            int n;

            int j1=y/100;
            int j2=y%100;
            if (m&amp;amp;gt;2) n=0; /*Якщо не січень та не лютий*/
            else {
            if (j2==0) {
            if (j1%4==0) n=1; /*не високосний*/
            else n=2; /*високосний*/
            } else {
            if (j2%4==0) n=1; /*не високосний*/
            else n=2; /*високосний*/
            }
            }
            long c=365.25*j2+30.56*m+n+d+2;
            int s=1+c%7;

            itoa(d, str, 10);
            strcat(str, &amp;amp;quot; &amp;amp;quot;);
            switch(s) {
            case 1: strcat(str, &amp;amp;quot;monday&amp;amp;quot;); break;
            case 2: strcat(str, &amp;amp;quot;tuesday&amp;amp;quot;); break;
            case 3: strcat(str, &amp;amp;quot;wednesday&amp;amp;quot;); break;
            case 4: strcat(str, &amp;amp;quot;thursday&amp;amp;quot;); break;
            case 5: strcat(str, &amp;amp;quot;friday&amp;amp;quot;); break;
            case 6: strcat(str, &amp;amp;quot;saturday&amp;amp;quot;); break;
            case 7: strcat(str, &amp;amp;quot;sunday&amp;amp;quot;); break;
            default: printf(&amp;amp;quot;error\n&amp;amp;quot;); exit(1);
            }
            strcat(str, &amp;amp;quot; &amp;amp;quot;);
            strcat(str, month[--m]);
            strcat(str, &amp;amp;quot; &amp;amp;quot;);
            itoa(y, str2, 10);
            strcat(str, str2);
            return str;
            }

            void main(void) {
            day_of_year(13, 3, 1997);
            printf(&amp;amp;quot;-%s\n&amp;amp;quot;, str);
            }

            8.3.
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #include &amp;amp;lt;stdlib.h&amp;amp;gt;
            int stack[20],k=1;
            void main(int argc ,char **argv)
            {char o;int rez;
            void push(int);
            if (argc==1) {printf(&amp;amp;quot;Usage: [program] [inverted polish note]-&amp;amp;quot;);exit(1);};
            printf(&amp;amp;quot;You must type each number and sign via key-SPACE,\nif you&amp;amp;apos;ve typed wrong
            the rezult is wrong...\n&amp;amp;quot;);

            for(int i=1;i&amp;amp;lt;argc;i++) /*Цикл по всіх аргументах*/
            { if ((48 &amp;amp;lt;= *(*(argv+i))) &amp;amp;&amp;amp; (*(*(argv+i))&amp;amp;lt;=57)) /*Якщо це число - */
            {printf(&amp;amp;quot;%d &amp;amp;quot;,atoi(argv[i]));
            push(atoi(argv[i])); k++;}/*Кладемо в стек */

            else { /* Якщо знак операції - */
            o=*argv[i]; /*Беремо зі стеку два числа , обчислюємо, результат - у стек*/
            printf(&amp;amp;quot;%c &amp;amp;quot;,o);
            switch (o) {
            case &amp;amp;apos;+&amp;amp;apos;:rez=stack[k-1]+stack[k-2]; k--;k--; push(rez); k++; break;
            case &amp;amp;apos;-&amp;amp;apos;:rez=stack[k-1]-stack[k-2]; k--;k--; push(rez); k++; break;
            case &amp;amp;apos;*&amp;amp;apos;:rez=stack[k-1]*stack[k-2]; k--;k--; push(rez); k++; break;
            case &amp;amp;apos;/&amp;amp;apos;:rez=stack[k-1]/stack[k-2]; k--;k--; push(rez); k++; break;
            default:printf(&amp;amp;quot; Error in statement&amp;amp;quot;);}
            }
            }
            printf(&amp;amp;quot;\nThe rezult is=%d&amp;amp;quot;,stack[k-1]);
            }
            void push(int a)
            { stack[k]=a;
            }


            8.3.C++

            #include &amp;amp;lt;stdlib.h&amp;amp;gt;
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #include &amp;amp;lt;ctype.h&amp;amp;gt;
            #define STK_LEN 100

            class stack {
            private:
            int stk[STK_LEN];
            int stknum;
            public:
            stack() {
            stknum=0;
            }

            void push(int a) {
            if (stknum==100) {
            puts(&amp;amp;quot;stack is full&amp;amp;quot;);
            exit(1);
            }
            stk[stknum++]=a;
            }

            int pop(void) {
            if (stknum==0) {
            puts(&amp;amp;quot;stack is empty&amp;amp;quot;);
            exit(1);
            }
            return stk[--stknum];
            }
            };

            void main(int argc, char *argv[]) {
            int integ, i;
            class stack s;
            if (argc==1) {
            puts(&amp;amp;quot;nothing to do&amp;amp;quot;);
            exit(1);
            }
            for (i=1; i&amp;amp;lt;=argc; i++) {
            if (isdigit(argv[i][0])) {
            s.push(atoi(argv[i]));
            } else if (argv[i][0]==&amp;amp;apos;+&amp;amp;apos;) {
            s.push(s.pop()+s.pop());
            } else if (argv[i][0]==&amp;amp;apos;-&amp;amp;apos;) {
            integ=s.pop();
            s.push(integ-s.pop());
            } else if (argv[i][0]==&amp;amp;apos;*&amp;amp;apos;) {
            s.push(s.pop()*s.pop());
            } else if (argv[i][0]==&amp;amp;apos;/&amp;amp;apos;) {
            integ=s.pop();
            s.push(integ/s.pop());
            } else if (argv[i][0]==&amp;amp;apos;%&amp;amp;apos;) {
            integ=s.pop();
            s.push(integ%s.pop());
            }
            }
            printf(&amp;amp;quot;%d\n&amp;amp;quot;, s.pop());
            }


            8.4.
            #include &amp;amp;lt;string.h&amp;amp;gt;
            #include &amp;amp;lt;stdlib.h&amp;amp;gt;
            #include &amp;amp;lt;stdio.h&amp;amp;gt;
            #define MAX_LINES 100
            #define MAX_STR_LEN 100

            void main(int argc, char *argv[]) {
            char strichka[MAX_LINES][MAX_STR_LEN];
            int n, read, i;

            if (argc==1) n=10; /*по замовченню n = 10*/
            else {
            n=atoi(argv[1]); /*iнакше - перший аргумент командного рядка*/
            }

            if (n&amp;amp;gt;MAX_LINES || n&amp;amp;lt;1) {
            puts(&amp;amp;quot;no room for lines&amp;amp;quot;);
            puts(&amp;amp;quot;n must be from 1 to 100&amp;amp;quot;);
            printf(&amp;amp;quot;now it is: %d\n&amp;amp;quot;, n);
            printf(&amp;amp;quot;argv[1]==%s\n&amp;amp;quot;, argv[1]);
            exit(1);
            }

            read=0;

            while (!feof(stdin)) {/*Читаємо рядки поки не Ctrl+Z*/
            gets(strichka[0]);
            for (i=read; i&amp;amp;gt;=0; i--) /*Зсуваємо їх у масиві після кожної
            прочитаної*/
            strcpy(strichka[i], strichka[i-1]);
            if (read&amp;amp;lt;=n) read++;
            }
            for (i=read; i&amp;amp;gt;1; i--) {/*В масиві strichka - n останніх прочитаних рядків*/
            printf(&amp;amp;quot;%s\n&amp;amp;quot;, strichka[i]);
            }
            }


        </answers>
    </tasks>
    Предметний вказівник

    Блок
    Буферизація
    Включення файлів
    Вираз
    - константний
    Змінні
    Ідентифікатор
    Клас пам&amp;amp;apos;яті
    Коментар
    Компіляція
    Константа
    Макровизначення
    Масив
    Мітка
    Оператор
    Операція
    Опис
    Параметри
    Перетворення
    Покажчик
    Поля
    Посилання
    Препроцесор
    Пріоритети операцій Програма
    Синтаксис
    Стрічка
    Структура
    Структура програми
    Суміш
    Типи даних
    Файл
    Функція

    Цикл 19
    70
    75
    14, 15
    14, 21
    31, 32, 41, 44
    26, 66
    40, 41, 44
    7
    37
    9, 12
    69,74
    12, 38, 48, 53, 54
    21, 26
    19, 31
    14, 16, 32, 33
    10, 33, 35
    7, 24, 30, 41, 57, 60
    49, 71
    33, 48, 54, 56, 62
    66
    6, 16
    6, 8, 13, 74, 75
    15
    6, 8, 18
    68
    12
    60, 62, 65
    6, 8
    67, 68
    9
    7, 26, 43, 69, 70
    28, 30, 35, 49, 52, 58, 63, 71
    17, 22, 25, 26 auto
    break
    case
    char
    continue
    default
    do
    double
    else
    extern
    float
    for
    goto
    if
    int
    long
    register
    return
    short
    sizeof
    static
    struct
    switch
    typedef
    union
    unsigned
    while
    #define
    #include
    40, 41, 42
    20, 21, 26
    21
    10
    26
    21
    25
    11, 16
    19
    7, 40
    11, 16
    23
    26
    19
    7, 9, 10, 16
    9, 10, 16
    40, 41
    7, 31
    9, 10, 16
    14, 74
    40, 41, 43, 53, 62, 67
    60, 61, 67, 68, 70
    20
    68, 69
    68
    9, 10, 16, 67
    22, 25
    74, 75
    75


    <literature_details>
        Література
        <lit_item>
            1. Белов Ю.А., Проценко В.С., Чаленко П.И. Інструментальні засоби програмування. К., 1993. 248 с.
        </lit_item>
        <lit_item>
            2. Болски М.И. Язык программирования Си: Справ. М., 1988. 96 с.
        </lit_item>
        <lit_item>
            3. Вирт Н. Алгоритмы + Структуры данных = Программы. М., 1985. 406с.
        </lit_item>
        <lit_item>
            4. Керниган Б., Ритчи Д., Фюэр А. Язык программирования Си. Задачи по языку. М., 1985. 279с.
        </lit_item>
        <lit_item>
            5. Проценко В.С., Чаленко П.И., Сорока Р.Н. Техника программирования. К., 1990. 183 с.
        </lit_item>
        <lit_item>
            6. Проценко В.С., Чаленко П.И., Ставровский А.Б. Техніка програмування Мовою Сі. К., 1993. 224 с.
        </lit_item>
    </literature_details>
</Book>
